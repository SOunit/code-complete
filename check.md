# チェックリスト 3-1 要求

```
この要求のチェックリストには、プロジェクトの要求について自問自答すべき質問が含まれている。
本書では、要求を正しく策定する方法は説明していないので 、このチェックリストにもそれに関するものは含まれていない 。
このチェックリストは 、コンストラクションの段階で土台がどれだけしっかりしているか 、
すなわち 、要求のマグニチュ ードを測定するためのサニティチェックとして役立ててほしい 。
チェックリストのすべての質問が 、すべてのプロジェクトに当てはまるとは限らない 。
非公式なプロジェクトに従事しているとしたら 、考える必要もない質問もあるだろう 。
また 、考える必要はあっても 、きちんと答える必要のない質問もあるだろう 。
ただし 、大規模で公式のプロジェクトに従事している場合は 、すべての質問を検討する必要がある 。
```

## 機能要求

- システムへの入力が 、その入力元 、精度 、範囲 、頻度を含め 、すべて明記されているか 。
- システムからの出力が 、その出力先 、精度 、範囲 、頻度を含め 、すべて明記されているか 。
- W e b ペ ージやレポ ートなどの出力形式がすべて明記されているか 。
- 外部のハ ードウェアインタ ーフェイスとソフトウェアインタ ーフェイスがすべて明記されているか 。
- 外部通信インタ ーフェイスが 、ハンドシェイク 、エラ ーチェック 、通信プロトコルを含め 、すべて明記されているか 。
- ユ ーザ ーが実行したいと考えているタスクがすべて明記されているか 。
- 各タスクで使用するデ ータと各タスクで生じるデ ータが明記されているか 。

## 非機能 （品質 ）要求

- ユ ーザ ー側から見て期待される応答時間は 、必要な操作すべてに明記されているか 。
- 処理時間 、デ ータ転送の速度 、システムのスループットなど 、時間に関するその他の検討事項が明記されているか 。
- セキュリティレベルが明記されているか 。
- ソフトウェアの障害による影響 、障害から保護しなければならない重要なデ ータ 、エラ ーの検出と回復の手順を含め 、信頼性が明記されているか 。
- 最低限必要なメモリ容量と空きディスク容量が明記されているか 。
- 特定の機能の変更 、動作環境の変更 、他のソフトウェアとのインタ ーフェイスの変更に対応する機能を含め 、システムの保守性が明記されているか 。
- 何をもって成功または失敗とするかが定義されているか 。

## 要求の品質

- 要求はユ ーザ ーの言葉で書かれているか 。ユ ーザ ーがそのように考えているか 。
- それぞれの要求が他の要求と矛盾していないか 。
- 競合する属性 （たとえば 、信頼性と正確性の妥協点 ）が明記されているか 。
- 要求が設計を規定していないか 。

- 要求の詳細さがほぼ一定であるか 、より詳細に明記すべき要求があるか 、詳細すぎる要求があるか 。
- 要求はコンストラクションに従事する別のグループに引き渡したとしても十分に明確で 、理解できる内容になっているか 。開発者がそのように考えているか 。
- 各項目が課題とそのソリュ ーションに関連しているか 。各項目は課題の発生源から追跡できるか 。
- 各要求はテストに対応しているか 。各要求が満たされたかどうかを独立したテストで判断できるか 。
- 要求に対して考えられる変更と 、その可能性がすべて明記されているか 。

## 要求の完全性

- 開発を始める前に情報を入手できないような 、不完全な領域が明記されているか 。
- 「製品がすべての要求を満たしていれば受け入れ可能である 」という意味において 、要求は完全であるか 。
- すべての要求が納得できるものか 。実装することが不可能な要求や 、顧客や上司をなだめるために盛り込まれた要求は削除されているか 。

# チェックリスト 3-2 アーキテクチャ

```
次に、優れたアーキテクチャが対処すべき問題点をまとめる。
このリストはアーキテクチャの総合ガイドではなく、ソフトウェアの食物連鎖の末端にいるプログラマが
どのような栄養分を摂取できるのかを評価するためのものである。このチェックリストを出発点に、
自分だけのチェックリストを完成させてほしい。
要求のチェックリストと同様、非公式なプロジェクトに従事している場合は、考える必要すらない項目がいくつかある。
しかし、大規模なプロジェクトに取り組んでいる場合は、ほとんどの項目が役立つだろう。
```

## アーキテクチャの詳細

- アーキテクチャの十分な概要や理由付けを含め、プログラムの全体的な構成が明らかになっているか。
- それぞれの構成単位が受け持つ領域や、他の構成単位とのインターフェイスを含め、主な構成単位がきちんと定義されているか。
- 要求に列挙されているすべての機能が、適切な数の構成単位によってきちんとカバーされているか。
- 最も重要なクラスの説明とその正当性が明記されているか。
- データ設計の説明とその正当性が明記されているか。
- データベースの構造や内容が明記されているか。
- 重要な業務ルールがすべて明記され、それらによるシステムへの影響が明記されているか。
- ユーザーインターフェイスの設計方針が説明されているか。
- ユーザーインターフェイスがモジュール化され、その変更がプログラムの他の部分に影響しないようになっているか。
- I/O の処理方針が明記され、その根拠が説明されているか。
- スレッド、データベース接続、ハンドル、ネットワークの帯域幅など、限られたリソースに対する使用量の見積もりやリソース管理の方針が明記され、その根拠が説明されているか。
- アーキテクチャのセキュリティ要件が明記されているか。
- 各クラス、サブシステム、または機能領域のためのスペースと速度が見積もられているか。
- スケーラビリティの実現方法が明記されているか。
- 相互運用性に対処しているか。
- 国際化/地域化の方針が明記されているか。
- 首尾一貫したエラー処理方針が明記されているか。
- フォールトトレランスの手法が定義されているか（必要であれば）。
- システムのすべての部分が技術的に実現可能か。
- オーバーエンジニアリングへの取り組み方が明記されているか。
- 購入するか構築するかの決断が含まれているか 。
- 再利用するコ ードをア ーキテクチャの他の目的に適合させる方法が説明されているか 。
- ア ーキテクチャは予想される変更に適応できる設計になっているか 。

## アーキテクチャの全体的な品質

- すべての要求に対処しているか 。
- 過剰に設計されている部分や設計が不十分な部分はないか 。この領域の期待値が明記されているか 。
- ア ーキテクチャ全体が概念的に矛盾していないか 。
- ア ーキテクチャはその実装に使用するマシンや言語から独立しているか 。
- 重大な決断すべてについて 、その理由が明記されているか 。
- システムを実装するプログラマとして 、あなたがア ーキテクチャに満足しているか 。

# チェックリスト 3-3 上流工程の必要性

- ソフトウェアプロジェクトの種類を特定し、それに合わせてアプローチを調整したか 。
- コンストラクションを開始するにあたって、要求が明確に定義され、確定しているか（詳しくは、要求のチェックリストを参照） 。
- コンストラクションを開始するにあたって、アーキテクチャが明確に定義されているか（詳しくは、アーキテクチャのチェックリストを参照） 。
- コンストラクションが必要以上にリスクにさらされないよう 、プロジェクト固有のリスクに対処しているか 。

# チェックリスト 4-1 主なコンストラクションプラクティス

## コ ーディング

- 事前に行う設計と 、コ ーディングしながらキ ーボ ードの前で行う設計を明確に定義しているか 。
- 名前 、コメント 、レイアウトのコ ーディング規約を定義しているか 。
- ア ーキテクチャが示唆する特定のコ ーディングプラクティスを定義しているか （たとえば 、エラ ーをどのように処理するか 、セキュリティ対策はどうするか 、クラスインタ ーフェイスにどのような規約を使用するか 、コ ードの再利用にどのような標準を適用するか 、コ ーディングの際にパフォ ーマンスをどの程度考慮するか 、など ） 。
- テクノロジの波のどの位置に乗っているのかを把握し 、それに合わせてアプロ ーチを調整しているか 。言語の 「中で 」のプログラミングに縛られずに 、言語の 「中へ 」のプログラミングの方法を特定しているか 。

## チ ームワ ーク

- 統合手続きを定義しているか 。つまり 、コ ードをマスタソ ースにチェックインする前に 、プログラマが踏まなければならない手続きを定義しているか 。
- ペアプログラミングを使用するのか 、 1 人でプログラミングするのか 、それともそれらを何らかの形で組み合わせるのか 。

## 品質保証

- プログラマは 、コ ード自体を書く前に 、コ ードのテストケ ースを書くか 。
- プログラマは 、コ ードの先か後かにかかわらず 、コ ードの単体テストを書くか 。
- プログラマは 、コ ードをチェックインする前に 、デバッガでコ ードをチェックするか 。
- プログラマは 、コ ードをチェックインする前に 、コ ードの統合テストを実施するか 。
- プログラマは 、互いのコ ードのレビュ ーやインスペクションを行うか 。

## ツ ール

- バ ージョン管理ツ ールを選択しているか 。
- 言語と言語のバ ージョン 、またはコンパイラのバ ージョンを選択しているか 。
- J 2 E E や M i c r o s o f t . N E T F r a m e w o r k といったフレ ームワ ークを選択しているか 。あるいは 、フレ ームワ ークを使用しないことをはっきりと決定しているか 。
- 言語の標準でない機能の使用を許可するかどうか決定しているか 。
- エディタ 、リファクタリングツ ール 、デバッガ 、テストフレ ームワ ーク 、構文チェッカ ーなど 、必要なツ ールを洗い出し 、入手しているか 。

# チェックリスト 5-1 コンストラクションにおける設計

## 設計のプラクティス

- 最初の作業ではなく 、何度か作業を繰り返して 、最も良いものを選択したか 。
- システムを何種類かの方法で分解し 、どの方法が最も良いか試したか 。
- 設計問題にトップダウン方式とボトムアップ方式の両方で取り組んだか 。
- システムの危険な部分やよくわからない部分のプロトタイプを作成し 、特定の問題に答える必要最小限の使い捨てコ ードを作成したか 。
- 設計を第三者による公式または非公式のレビュ ーにかけたか 。
- W i k i 、電子メ ール 、フリップチャ ート 、デジタル写真 、 U M L 、 C R C カ ード 、またはコ ードのコメントなど 、適切な方法で設計作業を記録したか 。

## 設計の目標

- ア ーキテクチャレベルで識別され 、先送りされた問題に 、設計が十分に対処しているか 。
- 設計が階層化されているか 。
- プログラムをサブシステム 、パッケ ージ 、クラスに分解する方法に満足しているか 。
- クラスをル ーチンに分解する方法に満足しているか 。
- クラスどうしの結合度が最小限になるように設計されているか 。
- クラスやサブシステムは他のシステムで利用できるように設計されているか 。
- プログラムは保守しやすいか 。
- 設計に無駄はないか 。すべての部分は本当に必要か 。
- 設計は標準的な手法を用いているか 。風変わりな理解しにくい要素を使用していないか 。
- 全体的に見て 、設計は偶発的な複雑さと本質的な複雑さを最小限に抑えるのに役立っているか 。

# チェックリスト 6-1 クラスの品質

## 抽象データ型

- プログラムに含まれるクラスを ADT として考え、その見地からインターフェイスを評価したか。

## 抽象化

- クラスに基本目標があるか 。
- クラスに良い名前が付き、その名前がクラスの基本目標を説明しているか。
- クラスのインターフェイスは一貫性のある抽象化を実現しているか。
- クラスのインターフェイスはクラスの使用法を明確に示しているか。
- クラスのインターフェイスは、そのサービスの実装方法について考えなくてもよいほど抽象化されているか。クラスをブラックボックスとして扱うことができるか。
- 他のクラスがそのクラスの内部データに干渉する必要がないほど、クラスのサービスの完成度は高いか。
- 関係のない情報をクラスの外へ移動したか 。
- クラスをコンポ ーネントのクラスに再分割することを検討し 、それをできるだけ細かく分けてみたか 。
- クラスを修正するときにクラスのインタ ーフェイスの整合性を維持しているか 。

## カプセル化

- クラスのメンバへのアクセスを最小限に抑えているか 。
- クラスのメンバデ ータの公開を避けているか 。
- プログラミング言語が許可する範囲内で 、クラスの実装の詳細を他のクラスから隠ぺいしているか 。
- 派生クラスを含むクラスのユ ーザ ーについて憶測していないか 。
- クラスが他のクラスに依存していないか 。疎結合か 。

## 継承

- 継承を 「 i s a 」関係のモデリングにのみ使用しているか 。つまり 、派生クラスがリスコフの置換原則に準拠しているか 。
- クラスの説明文に継承方法を記載しているか 。
- 派生クラスでオ ーバ ーライド不可能なル ーチンを 「オ ーバ ーライド 」していないか 。
- 共通のインタ ーフェイス 、デ ータ 、振る舞いを継承ツリ ーのできるだけ上のレベルに移動したか 。
- 継承ツリ ーは浅めにしているか 。
- 基底クラスのすべてのメンバデ ータを p r o t e c t e d ではなく p r i v a t e で宣言しているか 。

## その他の実装問題

- クラスに含まれているメンバデ ータの数は約 7 個またはそれ以下であるか 。
- クラスから他のクラスへの直接的または間接的なル ーチン呼び出しを最小限に抑えているか 。
- クラスが絶対に必要な範囲内で他のクラスと協力しているか 。
- すべてのメンバデ ータをコンストラクタで初期化しているか 。
- シャロ ーコピ ーを作成する明確な理由がない限り 、クラスがシャロ ーコピ ーではなくディ ープコピ ーを使用する設計になっているか 。

## 言語固有の問題

- 特定のプログラミング言語について 、クラスに関連する言語固有の問題を調査したか 。

# チェックリスト 7-1 高品質なルーチン

## 全体像

- ル ーチンを作成する理由は十分か 。
- 独自のル ーチンに分割することから利益を得られるすべての部分をル ーチンに分割したか 。
- ル ーチンの名前は効果的か 。プロシ ージャに 「動詞 ＋オブジェクト 」の明確な名前を付けているか 。関数に戻り値を説明するような名前を付けているか 。
- ル ーチンの名前はル ーチンが行うことをすべて説明しているか 。
- 一般的な処理に対する命名規則を定めているか 。
- ル ーチンの凝集度は強いか 。つまり 、 1 つの機能だけをうまく行うか 。
- ル ーチンの結合度は弱いか 。つまり 、ル ーチンどうしの結び付きが少なく 、扱いやすく 、明白で 、柔軟性があるか 。
- ル ーチンの長さは 、人工的なコ ーディング標準ではなく 、その関数やロジックによって自然に決定されているか 。

## 引数の受け渡し

- ル ーチンの引数リストは 、全体として 、一貫性のあるインタ ーフェイスの抽象化を実現しているか 。
- ル ーチンの引数は 、同様のル ーチンとの一致を含め 、合理的な順序で並んでいるか 。
- インタ ーフェイスの条件が明記されているか 。
- ル ーチンの引数は 7 個以下か 。
- 入力引数はそれぞれ使用されているか 。
- 出力引数はそれぞれ使用されているか 。
- 入力引数を作業用変数として使用していないか 。
- ル ーチンが関数である場合 、考えられるすべての状況において有効な値を返すか 。

# チェックリスト 8-1 防御的プログラミング

## 全般

- ル ーチンは不正な入力デ ータから自身を保護するか 。
- アサ ーションを使って 、事前条件と事後条件を含め 、条件を文書化しているか 。
- アサ ーションの使用は絶対に発生すべきでない条件の文書化に限定しているか 。
- ア ーキテクチャや上位レベルの設計で 、エラ ーの処理方法として特定のものを指定しているか 。
- ア ーキテクチャや上位レベルの設計で 、エラ ー処理では堅牢性と正当性のどちらを優先すべきかを指定しているか 。
- バリケ ードを築いてエラ ーによる被害を食い止め 、エラ ー処理を配慮しなければならないコ ードを減らしているか 。
- コ ードにデバッグエイドを使用しているか 。
- デバッグエイドは手間をかけずにオン /オフできるような方法で導入されているか 。
- 防御的プログラミングのコ ードの量は適切か （多すぎても少なすぎてもよくない ） 。
- 開発段階でのエラ ーの見落としを防ぐために 、防御的プログラミングテクニックを採用しているか 。

## 例外

- プロジェクトで例外処理のための標準手法を定義しているか 。
- 例外に代わる方法を検討しているか 。
- エラ ーはなるべくロ ーカルで処理し 、例外をスロ ーしないようにしているか 。
- コンストラクタやデストラクタで例外をスロ ーしていないか 。
- すべての例外の抽象化レベルが 、それらをスロ ーするル ーチンにとって適切か 。
- それぞれの例外に 、その例外に関する適切な背景情報がすべて含まれているか 。
- コ ードに空の c a t c h ブロックが含まれていないか （あるいは 、空の c a t c h ブロックを使用するのが妥当であれば 、そのことが文書化されているか ） 。

## セキュリティ

- 不正なデ ータを検査するコ ードは 、バッファオ ーバ ーフロ ー 、こっそり仕込まれた S Q L コマンドや H T M L コ ード 、整数の桁あふれ 、その他の悪質な入力の試みをチェックしているか 。
- エラ ーを返すコ ードをすべてチェックしているか 。
- すべての例外をキャッチしているか 。
- エラ ーメッセ ージがシステムへの侵入を手助けするような情報を提供していないか 。

# チェックリスト 9-1 疑似コードプログラミングプロセス

- 準備が完了していることを確認したか 。
- クラスで解決する問題を定義したか 。
- 概略レベルの設計は 、クラスと各ル ーチンの良い名前が思い浮かぶほど明確なものになっているか 。
- クラスとそのル ーチンをテストする方法について考えたか 。
- 主に安定したインタ ーフェイスと理解しやすい実装という観点から 、あるいは主にリソ ースや速度の観点から 、効率について考えたか 。
- 標準ライブラリや他のコ ードライブラリに再利用可能なル ーチンやコンポ ーネントがないかどうかを調べたか 。
- 参考資料に役に立ちそうなアルゴリズムが載っていないかどうかを調べたか 。
- 詳細な擬似コ ードを使って各ル ーチンを設計したか 。
- 擬似コ ードを頭の中で検査したか 。擬似コ ードは簡単に理解できたか 。
- 設計作業に戻る必要があるような警告 （グロ ーバルデ ータの使用 、別のクラスやル ーチンの方が適していると思われる処理など ）に注意を払ったか 。
- 擬似コ ードを正確なコ ードで表したか 。
- P P P を再帰的に適用して 、必要に応じてル ーチンをより小さなル ーチンに分解したか 。
- 条件を作成するときにそれらを文書化したか 。
- 冗長なコメントを削除したか 。
- 最初の作業で満足するのではなく 、作業を何度か繰り返して最も良い方法を選択したか 。
- コ ードを隅々まで理解しているか 。コ ードは理解しやすいか 。

# チェックリスト 10-1 データの使用に関する一般論

## 変数の初期化

- ル ーチンはそれぞれ入力引数の正当性を確認しているか 。
- 変数を最初に使用する場所の近くで宣言しているか 。
- 変数を可能な限り宣言時に初期化しているか 。
- 変数の宣言と初期化を同時に行うことができない場合 、変数を最初に使用する場所の近くで初期化しているか 。
- カウンタやアキュムレ ータは正しく初期化されているか 。必要であれば 、使用するたびに再初期化されるか 。
- コ ードが繰り返し実行される場合 、変数は正しく再初期化されているか 。
- コ ードをコンパイルしてもコンパイラの警告は出力されないか （もちろん 、すべての警告オプションを有効にしているか ） 。
- 言語が暗黙の宣言を使用する場合 、それらが原因で発生する問題への対策を講じているか 。

## デ ータの使用に関するその他の問題

- すべての変数のスコ ープを最小限に抑えているか 。
- 変数の参照は 、変数の持続間隔も寿命も 、できるだけ近くにまとめているか 。
- 制御構造とデ ータ型が対応しているか 。
- 宣言された変数はすべて使用しているか 。
- すべての変数が適切なタイミングでバインドされているか 。つまり 、バインディングの先送りによる柔軟性と 、それに伴う複雑さの増加との間で 、折り合いをつけているか 。
- それぞれの変数の目的は 1 つだけか 。それぞれの変数の意味は明確か 。隠れた意味を持っていないか 。

# チェックリスト 11-1 変数の命名

## 命名全般の検討事項

- 名前は 、変数が表すものを完全かつ正確に説明しているか 。
- 名前は 、プログラミング言語の解決策ではなく 、現実世界の問題を表しているか 。
- 名前は 、その意味を解読する必要がないほど十分に長いか 。
- 計算値を修飾子として使用する場合は 、名前の末尾に追加しているか 。
- 名前には、Num ではなく Count または Index を使用しているか。

## 特殊なデ ータの命名

- ループ変数に意味のある名前を付けているか （ 3 行以上にわたる長いループやネストしたループでは、i、j、k 以外の名前を使用する）。
- すべての 「一時 」変数を意味のある名前に変更したか 。
- ブ ール変数には 、真（true）の場合にそれらの意味が明確になるような名前を付けているか。
- 列挙型の名前には、Color_Red、Color_Green、Color*Blue の Color*のように、カテゴリを表すプレフィックスまたはサフィックスが含まれているか。
- 名前付き定数には 、それらが参照する数値ではなく 、それらが表す抽象的なエンティティに由来する名前が付いているか 。

## 命名規則

- 命名規則は 、ロ ーカルデ ータ 、クラスデ ータ 、グロ ーバルデ ータを区別するものになっているか 。
- 命名規則は 、型名 、名前付き定数 、列挙型 、変数を区別するものになっているか 。
- 命名規則は 、ル ーチンへの入力専用引数を識別しない言語でも 、それらを識別できるものになっているか 。
- 命名規則は 、言語の標準的な命名規則とできるだけ整合性のとれたものになっているか 。
- 名前は読みやすく構成されているか 。

## 短い名前

- 長い名前を使用しているか （短い名前を使用する必要がある場合を除く ） 。
- たった 1 文字を省略するために省略形を使用していないか 。
- すべての単語の省略形に一貫性があるか 。
- 発音できる名前を使用しているか 。
- 読み違えたり発音を誤ったりしやすい名前を使用していないか 。
- 短い名前を変換表にまとめているか 。

## 命名の一般的な問題 ： ‥避けるべき名前

- 誤解を招きやすい名前
- 似通った意味を持つ複数の名前
- 1 、 2 文字異なるだけの複数の名前
- 同じような発音の名前
- 数字を使用する名前
- 短くするために意図的に綴りを変えた名前
- 英語で綴りを間違えやすい名前
- 標準ライブラリのル ーチン名や既定の変数名と競合する名前
- 完全に独断的な名前
- 読みにくい文字

# チェックリスト 12-1 基本的なデータ

## 数値全般

- コ ードにマジックナンバ ーを使っていないか 。
- 「 0 による除算 」エラ ーが起きる可能性はないか 。
- 型の変換は明白か 。
- 同じ式に型の異なる変数が 2 つ使われている場合 、その式は正しく評価されるか 。
- 異なる型を比較していないか 。
- プログラムをコンパイルしても警告が出ないか 。

## 整数

- 整数の除算を行う式が正しく処理されているか 。
- 整数式で整数の桁あふれが起きないか 。

## 浮動小数点数

- 大きさが極端に異なる数の加算や減算を行っていないか 。
- 丸め誤差を体系的に防いでいるか 。
- 浮動小数点数の等価を比較していないか 。

## 文字と文字列

- マジックキャラクタやマジックストリングを使っていないか 。
- 文字列への参照に 「 1 つ違い 」エラ ーの可能性はないか 。
- C で文字列へのポインタと文字配列を別々に扱っているか 。
- C で文字列を定数 + 1 の長さで宣言するという規則に従っているか 。
- 適切であれば 、 C でポインタではなく文字配列を使っているか 。
- C で文字列を null に初期化して、無限文字列を防いでいるか。
- C で strcpy()ではなく strncpy()を使っているか。strncat()と strncmp()はどうか。

## ブ ール変数

- プログラムにブ ール変数を追加して 、条件の評価を文書化しているか 。
- プログラムにブ ール変数を追加して 、条件の評価を単純にしているか 。

## 列挙型

- 名前付き定数ではなく列挙型を使って 、プログラムの可読性 、信頼性 、保守性を改善しているか 。
- ブ ール変数では true と false の意味を完全に表現できない場合、ブール変数ではなく列挙型を使っているか。
- 列挙型を使って無効な値を評価しているか 。
- 列挙型の最初の値を 「無効 」なものとして予約しているか 。

## 名前付き定数

- デ ータの宣言やループの範囲指定にマジックナンバ ーではなく名前付き定数を使っているか 。
- 名前付き定数を一貫して使っているか 。名前付き定数を使っている部分とリテラルを使っている部分が混在していないか 。

## 配列

- 配列のすべてのインデックスが配列の有効範囲内にあるか 。
- 配列への参照に 「 1 つ違い 」エラ ーの可能性はないか 。
- 多次元配列のすべての添え字が正しい順番になっているか 。
- ネストしたループにおいて 、配列の添え字として正しい変数を使ってループインデックスのクロスト ークを防いでいるか 。

## 型の作成

- 変更の可能性があるデ ータに別の型を使っているか 。
- 型の名前は 、プログラミング言語の型ではなく 、型が表す現実世界のエンティティに基づいているか 。
- 型の名前はデ ータ宣言を文書化するくらいわかりやすいものになっているか 。
- 組み込み型を再定義していないか 。
- 単に型を再定義するのではなく 、新しいクラスを作成することについて検討したか 。

# チェックリスト 13-1 特殊なデータ型の使用に関する注意事項

## 構造体

- 変数をむき出しのまま使用せず 、構造体を使って関連するデ ータをグループにまとめ 、そのグループを操作しているか 。
- 構造体を使用する代わりにクラスを作成することを検討したか 。

## グロ ーバルデ ータ

- 間違いなくグロ ーバル変数でなければならないものを除き 、すべての変数をロ ーカル変数またはクラススコ ープで宣言しているか 。
- 変数の命名規則はロ ーカルデ ータ 、クラスデ ータ 、グロ ーバルデ ータを区別するものになっているか 。
- すべてのグロ ーバルデ ータは文書化されているか 。
- コ ードにグロ ーバルデ ータもどきが含まれていないか 。つまり 、巨大なオブジェクトに何もかも詰め込んですべてのル ーチンに渡していないか 。
- グロ ーバルデ ータの操作にアクセスル ーチンを使用しているか 。
- アクセスル ーチンとデ ータをクラスにまとめているか 。
- アクセスル ーチンは元のデ ータ型の実装を隠ぺいするような抽象化を実現しているか 。
- 関連するアクセスル ーチンの抽象化レベルが統一されているか 。

## ポインタ

- ポインタの操作をル ーチンとして独立させているか 。
- ポインタの参照は有効か 。ダングリング （未解決の ）ポインタになっていないか 。
- ポインタを使用する前に 、その有効性を確認しているか 。
- ポインタが参照する変数を使用する前に 、その有効性を確認しているか 。
- ポインタを解放した後 、 n u l l に設定しているか 。
- 必要なポインタ変数を惜しみなく使用して 、コ ードを読みやすくしているか 。
- リンクリストのポインタを正しい順序で解放しているか 。
- 緊急避難用のメモリを割り当て 、メモリが不足したときにプログラムをきちんと終了できるようにしているか 。
- 他に方法がない場合の最後の手段としてポインタを使用しているか 。

# チェックリスト 14-1 ストレートなコードの構成

- コ ードはステ ートメントどうしの依存性が明白になるように書かれているか 。
- ル ーチンに依存性が明白になるような名前が付いているか 。
- 依存性が明白でないものについてはコメントで説明しているか 。
- コ ードの重要な部分が順序に依存する場合に 、状態変数を使ってそれをチェックしているか 。
- コ ードは上から下へ読めるか 。
- 関連するステ ートメントを 1 つにまとめているか 。
- 密な依存関係にあるステ ートメントをル ーチンとして独立させているか 。

# チェックリスト 15-1 条件分の使用

## if-then 文

- 正常なケ ースの実行パスは明白になっているか 。
- if-then 文の等号と不等号の分岐は正しいか。
- else 句が明記され、文書化されているか。
- else 句は正しいか。
- if 句と else 句が正しく使われているか。逆になっていないか。
- 正常なケースは else 句ではなく if 句に続いて処理されているか。

## if-then-elseif の連鎖

- 複雑な評価をブ ール関数の呼び出しでカプセル化しているか 。
- 最も出現頻度の高いケ ースを最初に評価しているか 。
- すべてのケ ースをカバ ーしているか 。
- if-then-elseif の連鎖を実装するのが最適か。case 文よりも適しているか。

## case 文

- すべてのケ ースが意味のある順序で並んでいるか 。
- 各ケ ースの処理が単純に保たれ 、必要に応じて他のル ーチンを呼び出しているか 。
- case 文は、case 文を使用するためだけに作成された仮の変数ではなく、本物の変数を評価しているか。
- default 句を正しく使っているか。
- default 句を予想外のケースの検出と報告に使っているか。
- C、C++、Java で、case 文の最後に break 文を使っているか。

# チェックリスト 16-1 ループ

## ループの選択と作成

- for ループよりも while ループが適している場合は、while ループを使用しているか。
- ループを内から外へ作成したか 。

## ループの開始

- ループに先頭から入っているか 。
- 初期化コ ードはループの直前にあるか 。
- ループが無限ループまたはイベントループである場合 、 for i = 1 to 9999 といった不器用な方法ではなく、正攻法で作成しているか。
- ループが C++、C、または Java の for ループである場合、ループヘッダーをループの制御コードだけに使用しているか。

## ループの内容

- { と } 、またはそれに相当するものを使ってループ本体を囲み 、修正ミスによる問題を防いでいるか 。
- ループ本体で何らかの処理を行っているか 。空でないか 。
- 前処理や後処理のコ ードをループの先頭または末尾にまとめているか 。
- きちんと定義されたル ーチンと同様に 、ループでただ 1 つの機能を実行しているか 。
- ループは全体を一度に参照できるくらい短いか 。
- ループのネストは 3 段階以下になっているか 。
- ループの内容が長い場合はル ーチンとして独立させているか 。
- ループが長い場合は 、特に明確に書いているか 。

## ループ変数

- ループが f o r ループである場合 、ループの内部でループ変数を勝手に書き換えていないか 。
- ループ変数をループの外側で使用せず 、ループ変数の重要な値を変数に保存しているか 。
- ループ変数に序数または列挙を使用しているか 。浮動小数点数を使っていないか 。
- ループ変数に意味のある名前を付けているか 。
- ループ変数のクロスト ークを防いでいるか 。

## ループの終了

- ループはどのような状況下でも終了するか 。
- ループで安全カウンタを使用しているか （安全カウンタの標準を定めている場合 ） 。
- ループの終了条件は明確か 。
- break 文または continue 文を使用している場合、それらは正確か。

# チェックリスト 17-1 特殊な制御構造

## return 文

- 各ル ーチンは必要なときだけ return 文を使用しているか 。
- return 文によってコ ードが読みやすくなっているか 。

## 再帰

- 再帰ル ーチンに再帰を終了するためのコ ードが含まれているか 。
- 安全カウンタを使って再帰ル ーチンの終了を保証しているか 。
- 再帰は 1 つのル ーチンに限定されているか 。
- ル ーチンの再帰の深さはプログラムのスタックサイズの制限内に収まっているか 。
- 再帰はル ーチンを実装するための最善の手段か 。単純な反復よりもよいか 。

## go-to 文

- go-to 文はあくまでも最後の手段として使用しているか 。そして 、コ ードの可読性と保守性を改善する目的でのみ使用しているか 。
- 効率を良くするために go-to 文を使用している場合 、効率がどれだけ良くなるかを測定し 、そのことを明記しているか 。
- go-to 文のラベルはル ーチンにつき 1 つに制限しているか 。
- すべての go-to 文が前方に進むか 。後方に戻るものはないか 。
- すべての go-to ラベルが使用されているか 。

# チェックリスト 18-1 テーブル駆動方式

- 複雑なロジックの代替案としてテ ーブル駆動方式を検討したか 。
- 複雑な継承構造の代替案としてテ ーブル駆動方式を検討したか 。
- テ ーブルのデ ータを外部に保存し 、実行時にそれを読み取ることで 、コ ードを変更せずにデ ータを修正することを検討したか 。
- （ a g e の例のように ）単純なインデックス配列を使ってテ ーブルに直接アクセスできない場合 、コ ードでインデックスの計算を複製するのではなく 、アクセスキ ーの計算をル ーチンとして独立させているか 。

# チェックリスト 19-1 制御構造の問題

- 論理式に 1 と 0 ではなく true と false を使っているか。
- ブール値は true、false と暗黙に比較しているか。
- 数値は評価値と明示的に比較しているか。
- 新しいブール変数を追加したり、ブール関数やデシジョンテーブルを使用したりして、式を単純にしているか。
- ブール式は肯定的に表現しているか。
- 中かっこ（{}）は対になっているか。
- コードを明確にする必要があるすべての場所に、中かっこを使っているか。
- 論理式に完全にかっこ（()）を付けているか。
- 評価は数直線の順番に書かれているか。
- Java で評価を行う場合は、それが適切であれば、「a==b」形式でなく「a.equals(b)」形式を使っているか。
- null 文は明確に使われているか。
- 深くネストしたステートメントを使っている場合は、条件の一部を再評価する、if-then-else 文または case 文に書き換える、ネストしたコードをルーチンとして独立させる、設計をよりオブジェクト指向に書き換えるといった方法で単純化しているか、あるいは他の何らかの方法で改善しているか。
- ルーチンの判定ポイントが 10 個を超える場合、それを再設計しないことを説明するのに十分な理由があるか。

# チェックリスト 20-1 品質保証計画

- プロジェクトにとって重要な品質特性を特定したか。
- プロジェクトの品質目標をチームメンバに通知したか。
- 品質の外部特性と内部特性を区別したか。
- 特性が衝突し合う状況と補足し合う状況について考えたか。
- 種類の異なるエラーを検出するために、それぞれに適した数種類の欠陥検出テクニックを採用したか。
- ソフトウェア開発の各段階でソフトウェアの品質を検証する手順が計画に盛り込まれているか。
- 何らかの方法で品質を評価し、品質が向上したか低下したかを確認できるか。
- 品質保証のための追加コストを組み込んでおけば後のコストが削減できることを、経営陣が理解しているか。

# チェックリスト 21-1 効果的なペアプログラミング

- ペアを組んでいるプログラマが哲学的なコーディングスタイルについて議論を戦わせるのではなく、プログラミングに集中できるようなコーディング標準が設けられているか。
- 両方のパートナーが積極的に作業に参加しているか。
- すべてをペアプログラミングで済ませるのではなく、ペアプログラミングが効果を発揮するような割り当てを選択しているか。
- ペアの割り当てと作業の割り当てを定期的に交代しているか。
- ペアは作業ペースや性格の面でうまく折り合っているか。
- 管理面やプロジェクトの外部との調整役となるチームリーダーは存在するか。

# チェックリスト 22-1 テストケース

- クラスまたはルーチンに適用される要求ごとに、専用のテストケースを作成したか。
- クラスまたはルーチンに適用される設計要素ごとに、専用のテストケースを作成したか。
- コードの各行を少なくとも 1 つのテストケースでテストしたか。これを、すべてのコード行を調査するのに必要なテストの最小数を割り出すことによって確認したか。 -「定義された ─ 使用された」データフローのすべてのパスを少なくとも 1 つのテストケースでテストしたか。 -「定義された ─ 定義された」、「定義された ─ 抜けた」、「定義された ─ 破棄された」など、正しくないと思われるデータフローパターンについてコードをチェックしたか。
- 過去に頻繁に発生したエラーを検出するために、よくあるエラーのリストを使ってテストケースを作成したか。
- 単純な境界条件（最大値、最小値、 1 つ違いの境界値）をすべてテストしたか。
- 複合境界条件をテストしたか。つまり、変数に小さすぎる値や大きすぎる値が代入されるような入力データの組み合わせをテストしたか。
- データの種類が正しいかどうかをチェックするテストケースを作成したか。たとえば、給与計算プログラムの従業員数が負数の場合をテストしたか。
- 代表的な値（中間あたりの値）をテストしたか。
- 正常構成の最小値をテストしたか。
- 正常構成の最大値をテストしたか。
- 古いデータとの互換性をテストしたか。古いハードウェア、オペレーティングシステムの古いバージョン、ソフトウェアの古いバージョンとのインターフェイスをテストしたか。
- テストケースは手作業でも調べやすい内容か。

# チェックリスト 23-1 デバッグの覚え書き

## 欠陥検出のテクニック

- 手に入るすべてのデータを使って仮説を立てる。
- エラーを再現させるテストケースを改良する。
- 複数の単体テストでコードをテストする。
- ツールを駆使する。
- 何種類かの方法でエラーを再現する。
- データをさらに収集して仮説を増やす。
- 否定的なテストの結果を利用する。
- 新しい仮説をひねり出す。
- メモ帳を用意して、試してみることをリストアップする。
- 疑わしいコードの範囲を絞り込む。
- 以前に欠陥があったクラスやルーチンを疑う。
- 最近変更されたコードをチェックする。
- 調査範囲を広げる。
- 統合はインクリメンタルに行う。
- 一般的なエラーをチェックする。
- だれかと問題について話す。
- 問題から離れてみる。
- 間に合わせのデバッグには制限時間を設ける。
- ブルートフォースの手法をリストアップする。

## 構文エラーのためのテクニック

- コンパイラのメッセージの行番号をあてにしない。
- コンパイラのメッセージをあてにしない。
- コンパイラの 2 番目のメッセージをあてにしない。
- 分割して攻略する。
- コメント記号や引用符の閉じ忘れを探す。

## 欠陥修正のテクニック

- 問題を修正する前に理解する。
- 問題だけでなく、プログラムを理解する。
- エラーの診断を確認する。
- リラックスする。
- 元のソースコードを保存する。
- 症状ではなく問題を修正する。
- 正当な理由がある場合にのみコードを変更する。
- 変更は一度に 1 つずつ。
- 修正を確認する。
- 欠陥を明らかにする単体テストを追加する。
- 同様の欠陥を探す。

## デバッグへの一般的なアプローチ

- プログラム、誤り、コードの品質、問題解決アプローチを学ぶ機会として、デバッグを利用しているか。
- 試行錯誤の迷信めいたアプローチでデバッグしていないか。
- エラーは自分のミスであるという前提に立っているか。
- ときどきしか発生しないエラーを科学的な手法で安定させているか。
- 科学的な手法で欠陥を検出しているか。
- 毎回同じ方法を使用するのではなく、何種類かの方法で欠陥を検出しているか。
- 修正が正しいことを検証しているか。
- コンパイラの警告メッセージ、実行プロファイラ、テストフレームワーク、足場、対話型デバッグを利用しているか。

# チェックリスト 24-1 リファクタリングする理由

- コードが重複している。
- ルーチンが長すぎる。
- ループが長すぎる、またはネストが深すぎる。
- クラスのモジュール凝集度が小さい。
- クラスのインターフェイスが一貫性のある抽象化を実現していない。
- 引数リストの引数の数が多すぎる。
- 変更がクラス内部の他の部分に影響しない。
- 変更が発生したら複数のクラスを同時に修正しなければならない。
- 継承の階層を並行して修正しなければならない。
- case 文を並行して修正しなければならない。
- 一緒に使用する関連データがクラスにまとめられていない。
- ルーチンがそのクラスの機能よりも別のクラスの機能を多く使用する。
- 基本データ型をオーバーロードしている。
- クラスがほとんど何もしない。
- ルーチン間をトランプデータが流れる。
- 中間オブジェクトが何もしていない。
- あるクラスが別のクラスと密結合している。
- ルーチンの名前が不適切である。
- データメンバがパブリックである。
- サブクラスがスーパークラスのルーチンをほんの一部しか使用しない。
- 複雑なコードを説明するためにコメントが使われている。
- グローバル変数を使用している。
- ルーチンの呼び出し前に初期化コードが使用され、呼び出し後に後処理コードが使用されている。
- プログラムに先のことを考えたコードが含まれている。

# チェックリスト 24-2 リファクタリングの概要

## データレベルのリファクタリング

- マジックナンバーを名前付きの定数に置き換える。
- 変数名をより明白なものにするか、その目的がわかりやすいものに変える。
- 式をインラインにする。
- 式をルーチンに置き換える。
- 中間変数を導入する。
- 多目的変数を複数の単一目的変数に変換する。
- ローカルの目的には引数ではなくローカル変数を使用する。
- データプリミティブをクラスに変換する。
- 一連の型コードをクラスまたは列挙に変換する。
- 一連の型コードをスーパークラスとサブクラスに変換する。
- 配列をオブジェクトに変更する。
- コレクションをカプセル化する。
- 従来のレコードをデータクラスに置き換える。

## ステートメントレベルのリファクタリング

- 論理式を分解する。
- 複雑な論理式をわかりやすい名前の付いた論理関数にする。
- 条件文に分散している重複するコードを 1 つにまとめる。
- ループ制御変数でなく break や return を使用する。
- ネストした if-then-else ブロックで答えがわかったら、戻り値を代入せずに、すぐに制御を戻す。
- 条件文、特に case 文の繰り返しをポリモーフィズムで書き換える。
- null 値を評価するのではなく null オブジェクトを生成して使用する。

## ルーチンレベルのリファクタリング

- ルーチンやメソッドを抽出する。
- ルーチンのコードをインラインにする。
- 長いルーチンをクラスに変換する。
- 複雑なアルゴリズムを単純なアルゴリズムで代用する。
- 引数を追加する。
- 引数を削除する。
- 照会と変更を分離する。
- 同じようなルーチンを引数を介在させてまとめる。
- 入力引数によって振る舞いの異なるルーチンを分離する。
- 特定のフィールドではなくオブジェクト全体を渡す。
- オブジェクト全体ではなく特定のフィールドを渡す。
- ダウンキャストをカプセル化する。

## クラス実装のリファクタリング

- 値オブジェクトを参照オブジェクトに変更する。
- 参照オブジェクトを値オブジェクトに変更する。
- 仮想ルーチンをデータの初期化に置き換える。
- メンバルーチンまたはメンバデータの配置を変更する。
- 特殊なコードをサブクラスとして抽出する。
- 同じようなコードをスーパークラスにまとめる。

## クラスインターフェイスのリファクタリング

- ルーチンを別のクラスに移動する。
- 1 つのクラスを 2 つに分ける。
- クラスを削除する。
- 委譲を隠ぺいする。
- 中間オブジェクトを削除する。
- 継承を委譲に置き換える。
- 委譲を継承に置き換える。
- 外部ルーチンを導入する。
- 拡張クラスを導入する。
- 公開されているメンバ変数をカプセル化する。
- 変更できないフィールドの Set()ルーチンを削除する。
- クラスの外側で使用されないルーチンを隠ぺいする。
- 使用されないルーチンをカプセル化する。
- スーパークラスとサブクラスの実装が非常によく似ている場合は 1 つにまとめる。

## システムレベルのリファクタリング

- 制御できないデータについては、最も信頼のおけるデータソースを作成する。
- 一方向のクラス結合を双方向のクラス結合に変更する。
- 双方向のクラス結合を一方向のクラス結合に変更する。
- 単純なコンストラクタではなくファクトリメソッドを提供する。
- エラーコードを例外に置き換える、または例外をエラーコードに置き換える。

# チェックリスト 24-3 安全なリファクタリング

- それぞれの変更が体系的な変更戦略に従っているか。
- リファクタリングを開始する前に、最初のコードを保存したか。
- リファクタリングをそれぞれ小さく保っているか。
- リファクタリングを一度に 1 つずつ行っているか。
- リファクタリングの際に予定している作業手順をリストアップしているか。
- リファクタリング中に思い付いたアイデアを覚えておけるように、駐車スペースを設けているか。
- リファクタリングが済んだら必ず再テストしているか。
- 変更が複雑である場合、あるいは変更が基幹コードに影響する場合、それらをレビューしたか。
- 特定のリファクタリングの危険度について検討し、それに従って手順を調整したか。
- 変更によってプログラムの内部品質が改善されているか。低下していないか。
- コードや修正を埋め合わせるために、あるいは悪いコードを書き直さないことの言い訳として、リファクタリングを使用していないか。

# チェックリスト 25-1 コードチューニング戦略

## プログラムの全体的なパフォーマンス

- プログラムの要求を変えることによりパフォーマンスを改善することを検討したか。
- プログラムの設計を変えることによりパフォーマンスを改善することを検討したか。
- クラスの設計を変えることによりパフォーマンスを改善することを検討したか。
- オペレーティングシステムとのやり取りをなくすことによりパフォーマンスを改善することを検討したか。
- I/ O をなくすことによりパフォーマンスを改善することを検討したか。
- インタープリタ言語の代わりにコンパイル言語を使用することによりパフォーマンスを改善することを検討したか。
- コンパイラの最適化を使ってパフォーマンスを改善することを検討したか。
- ハードウェアを別のものに交換することによりパフォーマンスを改善することを検討したか。
- コードチューニングを最後の手段として検討したか。

## コードチューニングへのアプローチ

- コードチューニングを始める前のプログラムは完全に正確なものか。
- コードチューニングを始める前にパフォーマンスのボトルネックを測定したか。
- コードチューニングによる変更の効果をそれぞれ測定したか。
- 予想したような改善が見られなかった変更は元に戻したか。
- パフォーマンスのそれぞれのボトルネックを改善するために 1 つ以上の変更を試したか。つまり、繰り返したか。

# チェックリスト 26-1 コードチューニングテクニック

## 速度とサイズの改善

- 複雑なロジックをテーブル参照に置き換える。
- ループをジャミングする。
- 浮動小数点数型の変数の代わりに整数型の変数を使用する。
- データをコンパイル時に初期化する。
- 正しい型の定数を使用する。
- 結果をあらかじめ計算しておく。
- 共通の部分式を削除する。
- 重要なルーチンを低水準言語で書き換える。

## 速度のみの改善

- 答えがわかった時点で評価を終了する。
- case 文と if-then-else の連鎖は頻度の高い順に並べる。
- 同様の論理構造のパフォーマンスを比較する。
- 遅延評価を使用する。
- ループ内で if 文の分岐を行わない。
- ループを展開する。
- ループ内の処理は最小限に抑える。
- 検索ループに sentinel 値を使用する。
- ネストしたループの内側に最もビジーなループを入れる。
- ループ内で実行する操作の強度を削減する。
- 多次元配列を 1 次元配列に変更する。
- 配列参照を最小限に抑える。
- データ型をインデックスで補足する。
- 頻繁に使用する値をキャッシュする。
- 代数的な恒等式を活用する。
- 論理式と数学式の強度を削減する。
- システムルーチンに警戒する。
- ルーチンをインラインに書き直す。

# チェックリスト 28-1 構成管理

## 全般

- SCM 計画は、プログラマを手助けし、オーバーヘッドを最小限に抑えるものになっているか。
- SCM によるプロジェクトの管理は過剰になっていないか。
- 変更要求は、非公式の方法（保留になっている変更のリストなど）を通じて、あるいはより体系的なアプローチ（変更管理委員会など）を通じてまとめているか。
- 変更要求によるコスト、スケジュール、品質への影響を体系的に予測しているか。
- 大きな変更は要求の策定がまだ完了していないことの危険信号であると見なしているか。

## ツール

- バージョン管理ソフトウェアを使って、構成管理を促進しているか。
- バージョン管理ソフトウェアを使って、チーム作業の行き違いからくる問題を減らしているか。

## バックアップ

- プロジェクトのすべての資産を定期的にバックアップしているか。
- プロジェクトのバックアップを定期的に別の保管場所へ移動しているか。
- ソースコード、ドキュメント、グラフィックス、および重要なメモを含め、すべての資産をバックアップしているか。
- バックアップの復元手順をテストしているか。

# チェックリスト 29-1 統合

## 統合戦略

- 統合戦略はサブシステム、クラス、ルーチンを統合する最適な順序を明らかにしているか。
- クラスが正しいタイミングで統合できる状態になるよう、統合の順序をコンストラクションの順序に合わせて調整しているか。
- 統合戦略は欠陥を診断しやすいものになっているか。
- 統合戦略は足場を最小限に抑えるものになっているか。
- 他の方法よりも優れているか。
- コンポーネント間のインターフェイスを明確に定義しているか（インターフェイスの定義自体は統合作業ではないが、それらがきちんと定義されているかどうかを確認することは統合作業である）。

## デイリービルドとスモークテスト

- インクリメンタル型の統合をサポートするためにプロジェクトを頻繁に（理想的には毎日）ビルドしているか。
- ビルドごとにスモークテストを実施して、ビルドがうまくいったかどうかを確認しているか。
- ビルドとスモークテストを自動化しているか。
- 開発者が各自のコードを頻繁に検査しているか。チェックインの間隔が 1 日あるいは 2 日以上開いていないか。
- スモークテストがコードに追いついているか。スモークテストがコードと一緒に進化しているか。
- ビルドが失敗することはまれか。
- 切迫した状況下でもソフトウェアのビルドとスモークテストを実施しているか。

# チェックリスト 30-1 プログラミングツール

- 効果的な IDE を入手しているか。
- その IDE は、ソースコード管理ツール、ビルドツール、テストツール、デバッグツール、その他の便利な機能をサポートしているか。
- 一般的なリファクタリングを自動化するツールを持っているか。
- ソースコード、コンテンツ、要求、設計、プロジェクト計画、その他プロジェクトの成果物をバージョン管理システムを使って管理しているか。
- かなり大規模なプロジェクトに取り組んでいる場合、データディクショナリや何らかの中央リポジトリに、システムで使用される各クラスの信頼できる説明が含まれているか。
- カスタムコードを作成する代わりにコードライブラリを使用することを検討したか。
- 対話型デバッガを利用しているか。
- make などの依存性を管理するソフトウェアを使って、プログラムを効率よく確実にビルドしているか。
- テスト環境に、自動テストフレームワーク、自動テスト生成ツール、カバレッジモニタ、システム混乱ツール、 diff ツール、エラー追跡ソフトウェアが含まれているか。
- 特定のプロジェクトのニーズを満たすためのカスタムツール、特に反復的なタスクを自動化するツールを作成したか。
- 全体的に見て、十分なツールサポートの効果が環境に表れているか。

# チェックリスト 31-1 レイアウト

## 全般

- 主にコードの論理構造を浮き彫りにすることを目的にフォーマットしているか。
- そのフォーマット方法を一貫して使用できるか。
- そのフォーマット方法を採用すると、コードが保守しやすくなるか。
- そのフォーマット方法を採用すると、コードが読みやすくなるか。

## 制御構造

- begin-end または中かっこ（{ }）の組を二重にインデントしていないか。
- 連続するブロックがそれぞれ空行で区切られているか。
- 複雑な式が読みやすくフォーマットされているか。
- 1 行のステートメントブロックのフォーマットに一貫性があるか。
- case 文のフォーマットに他の制御構造のフォーマットとの一貫性があるか。
- goto 文はそれらを使用していることがはっきりとわかるような方法でフォーマットされているか。

## 個々のステートメント

- 空白を使って、論理式、配列参照、ルーチンの引数を読みやすくしているか。
- 完結していないステートメントは、どう見ても不正であることがわかるような形式で終わっているか。
- 継続行に標準のインデントを使用しているか。
- 1 行に含まれるステートメントが 1 つ以下になっているか。
- 各ステートメントは副作用がないように書かれているか。
- 1 行に含まれるデータ宣言が 1 つ以下になっているか。

## コメント

- コメントは、それらが説明するコードと同じ数のスペースでインデントされているか。
- コメントのスタイルは保守しやすいものになっているか。

## ルーチン

- 各ルーチンの引数は、読みやすく、変更しやすく、コメントを付けやすいフォーマットになっているか。
- 空行を使ってルーチンの各部分を区切っているか。

## クラス、ファイル、プログラム

- ほとんどのクラスやファイルについて、クラスとファイルが 1 対 1 の関係にあるか。
- ファイルに複数のクラスが含まれている場合、各クラスのすべてのルーチンが 1 つのグループにまとめられ、各クラスがはっきりと識別されているか。
- ファイル内のルーチンが空行でわかりやすく区切られているか。
- 構成上の規則を厳密に定める代わりに、すべてのルーチンをアルファベット順に並べているか。

# チェックリスト 32-1 読めばわかるコード

## クラス

- クラスのインターフェイスは一貫性のある抽象化を実現しているか。
- クラスに良い名前が付いていて、その名前がクラスの基本目標を説明しているか。
- クラスのインターフェイスはクラスの使用法を明確に示しているか。
- クラスのインターフェイスは、そのサービスの実装方法について考えなくてもよいほど抽象化されているか。クラスをブラックボックスとして扱うことができるか。

## ルーチン

- 各ルーチンの名前は、ルーチンが行うことを正確に説明しているか。
- 各ルーチンは明確に定義された 1 つのタスクを実行するか。
- 独自のルーチンに分割することが望ましいすべての部分をルーチンに分割したか。
- 各ルーチンのインターフェイスは自明かつ明確であるか。

## データ名

- 型名はデータ宣言を説明するのに十分な名前か。
- 変数名は適切か。
- 変数はその名前が示す目的にのみ使用されているか。
- ループカウンタに、 i、 j、 k のような名前ではなく、意味のある名前を付けているか。
- その場しのぎのフラグやブール変数ではなく、適切な名前の列挙型を使用しているか。
- マジックナンバーやマジックストリングの代わりに、名前付き定数を使用しているか。
- 命名規則は、型名、列挙型、名前付き定数、ローカル変数、クラス変数、グローバル変数を区別するものになっているか。

## データの構成

- コードを明確にするために必要に応じて変数を余分に使用しているか。
- 変数への参照をできるだけ近くにまとめているか。
- データ型を単純なものにして、複雑さを最小限に抑えているか。
- 複雑なデータには抽象的なアクセスルーチン（抽象データ型）を使ってアクセスしているか。

## 制御構造

- 通常のケースの実行パスはわかりやすいか。
- 関連するステートメントを 1 つにまとめているか。
- 比較的独立したステートメントのグループを独自のルーチンにまとめているか。
- 通常のケースは else 句ではなく if 句に続いて処理されているか。
- 適切に定義されたルーチンと同様に、ループでただ 1 つの機能を実行しているか。
- ネストは最小限に抑えているか。
- ブール変数、ブール関数、デシジョンテーブルを追加することにより、論理式を単純にしているか。

## レイアウト

- プログラムのレイアウトはその論理構造を表しているか。

## 設計

- コードはストレートに書かれているか。技巧に走っていないか。
- 実装の詳細をできるだけ隠ぺいしているか。
- コンピュータサイエンスやプログラミング言語構造の用語ではなく、問題領域の言葉でプログラムが書かれているか。

# チェックリスト 32-2 良いコメントの作成テクニック

## 全般

- コードを手に取った人が、そのコードをすぐに理解できるか。
- コメントは単なるコードの繰り返しではなく、コードの意図を説明しているか。コードが行うことを要約しているか。
- PPP を使ってコメントの作成にかかる時間を短縮しているか。
- トリッキーなコードには、コメントを付けるのではなく、コード自体を書き直しているか。
- コメントは最新のものか。
- コメントは明確で正しいか。
- コメントスタイルはコメントを簡単に変更できるようなものか。

## ステートメントと段落

- コードに行末コメントを使用していないか。
- コメントは方法ではなく理由に焦点を合わせているか。
- 読み手がコードの流れを追いやすいコメントになっているか。
- すべてのコメントが重要か。重複している、無関係である、あるいは自分勝手なコメントを削除または改良したか。
- 意外な事実を文書化しているか。
- 省略表記は避けているか。
- メジャーコメントとマイナーコメントを明確に区別しているか。
- エラーやドキュメントに記載されていない機能に対処するためのコードにコメントを付けているか。

## データ宣言

- 宣言するデータの単位をコメントで説明しているか。
- 数値データの値の範囲をコメントで説明しているか。
- コードの意味をコメントで説明しているか。
- 入力データに関する制限をコメントで説明しているか。
- フラグについてはビットレベルで文書化しているか。
- グローバル変数をそれぞれ宣言時にコメントで説明しているか。
- 各グローバル変数の目的を、命名規則、コメント、またはその両方で識別しているか。
- マジックナンバーを単に文書化するのではなく、名前付き定数や変数と置き換えているか。

## 制御構造

- 制御文にそれぞれコメントが付いているか。
- 長い制御構造や複雑な制御構造の終わりをコメントで示しているか。可能であれば、コメントの必要がないように単純化しているか。

## ルーチン

- 各ルーチンの目的をコメントで説明しているか。
- 入出力引数、インターフェイスの前提条件、制限、エラーの修正、グローバルな影響、アルゴリズムの出典など、各ルーチンの詳細をコメントに明記しているか。

## ファイル、クラス、プログラム

- 「本のパラダイム」で説明したような、プログラムの構成の全体像を明らかにする短いドキュメントがプログラムに含まれているか。
- 各ファイルの目的を説明しているか。
- コードの作成者の名前、電子メールアドレス、電話番号をリストに盛り込んでいるか。
