# チェックリスト 3-1

```
この要求のチェックリストには、プロジェクトの要求について自問自答すべき質問が含まれている。
本書では、要求を正しく策定する方法は説明していないので 、このチェックリストにもそれに関するものは含まれていない 。
このチェックリストは 、コンストラクションの段階で土台がどれだけしっかりしているか 、
すなわち 、要求のマグニチュ ードを測定するためのサニティチェックとして役立ててほしい 。
チェックリストのすべての質問が 、すべてのプロジェクトに当てはまるとは限らない 。
非公式なプロジェクトに従事しているとしたら 、考える必要もない質問もあるだろう 。
また 、考える必要はあっても 、きちんと答える必要のない質問もあるだろう 。
ただし 、大規模で公式のプロジェクトに従事している場合は 、すべての質問を検討する必要がある 。
```

## 機能要求

- システムへの入力が 、その入力元 、精度 、範囲 、頻度を含め 、すべて明記されているか 。
- システムからの出力が 、その出力先 、精度 、範囲 、頻度を含め 、すべて明記されているか 。
- W e b ペ ージやレポ ートなどの出力形式がすべて明記されているか 。
- 外部のハ ードウェアインタ ーフェイスとソフトウェアインタ ーフェイスがすべて明記されているか 。
- 外部通信インタ ーフェイスが 、ハンドシェイク 、エラ ーチェック 、通信プロトコルを含め 、すべて明記されているか 。
- ユ ーザ ーが実行したいと考えているタスクがすべて明記されているか 。
- 各タスクで使用するデ ータと各タスクで生じるデ ータが明記されているか 。

## 非機能 （品質 ）要求

- ユ ーザ ー側から見て期待される応答時間は 、必要な操作すべてに明記されているか 。
- 処理時間 、デ ータ転送の速度 、システムのスループットなど 、時間に関するその他の検討事項が明記されているか 。
- セキュリティレベルが明記されているか 。
- ソフトウェアの障害による影響 、障害から保護しなければならない重要なデ ータ 、エラ ーの検出と回復の手順を含め 、信頼性が明記されているか 。
- 最低限必要なメモリ容量と空きディスク容量が明記されているか 。
- 特定の機能の変更 、動作環境の変更 、他のソフトウェアとのインタ ーフェイスの変更に対応する機能を含め 、システムの保守性が明記されているか 。
- 何をもって成功または失敗とするかが定義されているか 。

## 要求の品質

- 要求はユ ーザ ーの言葉で書かれているか 。ユ ーザ ーがそのように考えているか 。
- それぞれの要求が他の要求と矛盾していないか 。
- 競合する属性 （たとえば 、信頼性と正確性の妥協点 ）が明記されているか 。
- 要求が設計を規定していないか 。

- 要求の詳細さがほぼ一定であるか 、より詳細に明記すべき要求があるか 、詳細すぎる要求があるか 。
- 要求はコンストラクションに従事する別のグループに引き渡したとしても十分に明確で 、理解できる内容になっているか 。開発者がそのように考えているか 。
- 各項目が課題とそのソリュ ーションに関連しているか 。各項目は課題の発生源から追跡できるか 。
- 各要求はテストに対応しているか 。各要求が満たされたかどうかを独立したテストで判断できるか 。
- 要求に対して考えられる変更と 、その可能性がすべて明記されているか 。

## 要求の完全性

- 開発を始める前に情報を入手できないような 、不完全な領域が明記されているか 。
- 「製品がすべての要求を満たしていれば受け入れ可能である 」という意味において 、要求は完全であるか 。
- すべての要求が納得できるものか 。実装することが不可能な要求や 、顧客や上司をなだめるために盛り込まれた要求は削除されているか 。

# チェックリスト 3-2

```
次に、優れたアーキテクチャが対処すべき問題点をまとめる。
このリストはアーキテクチャの総合ガイドではなく、ソフトウェアの食物連鎖の末端にいるプログラマが
どのような栄養分を摂取できるのかを評価するためのものである。このチェックリストを出発点に、
自分だけのチェックリストを完成させてほしい。
要求のチェックリストと同様、非公式なプロジェクトに従事している場合は、考える必要すらない項目がいくつかある。
しかし、大規模なプロジェクトに取り組んでいる場合は、ほとんどの項目が役立つだろう。
```

## アーキテクチャの詳細

- アーキテクチャの十分な概要や理由付けを含め、プログラムの全体的な構成が明らかになっているか。
- それぞれの構成単位が受け持つ領域や、他の構成単位とのインターフェイスを含め、主な構成単位がきちんと定義されているか。
- 要求に列挙されているすべての機能が、適切な数の構成単位によってきちんとカバーされているか。
- 最も重要なクラスの説明とその正当性が明記されているか。
- データ設計の説明とその正当性が明記されているか。
- データベースの構造や内容が明記されているか。
- 重要な業務ルールがすべて明記され、それらによるシステムへの影響が明記されているか。
- ユーザーインターフェイスの設計方針が説明されているか。
- ユーザーインターフェイスがモジュール化され、その変更がプログラムの他の部分に影響しないようになっているか。
- I/O の処理方針が明記され、その根拠が説明されているか。
- スレッド、データベース接続、ハンドル、ネットワークの帯域幅など、限られたリソースに対する使用量の見積もりやリソース管理の方針が明記され、その根拠が説明されているか。
- アーキテクチャのセキュリティ要件が明記されているか。
- 各クラス、サブシステム、または機能領域のためのスペースと速度が見積もられているか。
- スケーラビリティの実現方法が明記されているか。
- 相互運用性に対処しているか。
- 国際化/地域化の方針が明記されているか。
- 首尾一貫したエラー処理方針が明記されているか。
- フォールトトレランスの手法が定義されているか（必要であれば）。
- システムのすべての部分が技術的に実現可能か。
- オーバーエンジニアリングへの取り組み方が明記されているか。
- 購入するか構築するかの決断が含まれているか 。
- 再利用するコ ードをア ーキテクチャの他の目的に適合させる方法が説明されているか 。
- ア ーキテクチャは予想される変更に適応できる設計になっているか 。

## アーキテクチャの全体的な品質

- すべての要求に対処しているか 。
- 過剰に設計されている部分や設計が不十分な部分はないか 。この領域の期待値が明記されているか 。
- ア ーキテクチャ全体が概念的に矛盾していないか 。
- ア ーキテクチャはその実装に使用するマシンや言語から独立しているか 。
- 重大な決断すべてについて 、その理由が明記されているか 。
- システムを実装するプログラマとして 、あなたがア ーキテクチャに満足しているか 。

# チェックリスト 3-3 上流工程の必要性

- ソフトウェアプロジェクトの種類を特定し、それに合わせてアプローチを調整したか 。
- コンストラクションを開始するにあたって、要求が明確に定義され、確定しているか（詳しくは、要求のチェックリストを参照） 。
- コンストラクションを開始するにあたって、アーキテクチャが明確に定義されているか（詳しくは、アーキテクチャのチェックリストを参照） 。
- コンストラクションが必要以上にリスクにさらされないよう 、プロジェクト固有のリスクに対処しているか 。

# チェックリスト 4-1 主なコンストラクションプラクティス

## コ ーディング

- 事前に行う設計と 、コ ーディングしながらキ ーボ ードの前で行う設計を明確に定義しているか 。
- 名前 、コメント 、レイアウトのコ ーディング規約を定義しているか 。
- ア ーキテクチャが示唆する特定のコ ーディングプラクティスを定義しているか （たとえば 、エラ ーをどのように処理するか 、セキュリティ対策はどうするか 、クラスインタ ーフェイスにどのような規約を使用するか 、コ ードの再利用にどのような標準を適用するか 、コ ーディングの際にパフォ ーマンスをどの程度考慮するか 、など ） 。
- テクノロジの波のどの位置に乗っているのかを把握し 、それに合わせてアプロ ーチを調整しているか 。言語の 「中で 」のプログラミングに縛られずに 、言語の 「中へ 」のプログラミングの方法を特定しているか 。

## チ ームワ ーク

- 統合手続きを定義しているか 。つまり 、コ ードをマスタソ ースにチェックインする前に 、プログラマが踏まなければならない手続きを定義しているか 。
- ペアプログラミングを使用するのか 、 1 人でプログラミングするのか 、それともそれらを何らかの形で組み合わせるのか 。

## 品質保証

- プログラマは 、コ ード自体を書く前に 、コ ードのテストケ ースを書くか 。
- プログラマは 、コ ードの先か後かにかかわらず 、コ ードの単体テストを書くか 。
- プログラマは 、コ ードをチェックインする前に 、デバッガでコ ードをチェックするか 。
- プログラマは 、コ ードをチェックインする前に 、コ ードの統合テストを実施するか 。
- プログラマは 、互いのコ ードのレビュ ーやインスペクションを行うか 。

## ツ ール

- バ ージョン管理ツ ールを選択しているか 。
- 言語と言語のバ ージョン 、またはコンパイラのバ ージョンを選択しているか 。
- J 2 E E や M i c r o s o f t . N E T F r a m e w o r k といったフレ ームワ ークを選択しているか 。あるいは 、フレ ームワ ークを使用しないことをはっきりと決定しているか 。
- 言語の標準でない機能の使用を許可するかどうか決定しているか 。
- エディタ 、リファクタリングツ ール 、デバッガ 、テストフレ ームワ ーク 、構文チェッカ ーなど 、必要なツ ールを洗い出し 、入手しているか 。

# チェックリスト 5-1 コンストラクションにおける設計

## 設計のプラクティス

- 最初の作業ではなく 、何度か作業を繰り返して 、最も良いものを選択したか 。
- システムを何種類かの方法で分解し 、どの方法が最も良いか試したか 。
- 設計問題にトップダウン方式とボトムアップ方式の両方で取り組んだか 。
- システムの危険な部分やよくわからない部分のプロトタイプを作成し 、特定の問題に答える必要最小限の使い捨てコ ードを作成したか 。
- 設計を第三者による公式または非公式のレビュ ーにかけたか 。
- W i k i 、電子メ ール 、フリップチャ ート 、デジタル写真 、 U M L 、 C R C カ ード 、またはコ ードのコメントなど 、適切な方法で設計作業を記録したか 。

## 設計の目標

- ア ーキテクチャレベルで識別され 、先送りされた問題に 、設計が十分に対処しているか 。
- 設計が階層化されているか 。
- プログラムをサブシステム 、パッケ ージ 、クラスに分解する方法に満足しているか 。
- クラスをル ーチンに分解する方法に満足しているか 。
- クラスどうしの結合度が最小限になるように設計されているか 。
- クラスやサブシステムは他のシステムで利用できるように設計されているか 。
- プログラムは保守しやすいか 。
- 設計に無駄はないか 。すべての部分は本当に必要か 。
- 設計は標準的な手法を用いているか 。風変わりな理解しにくい要素を使用していないか 。
- 全体的に見て 、設計は偶発的な複雑さと本質的な複雑さを最小限に抑えるのに役立っているか 。

# チェックリスト 6-1 クラスの品質

## 抽象データ型

- プログラムに含まれるクラスを ADT として考え、その見地からインターフェイスを評価したか。

## 抽象化

- クラスに基本目標があるか 。
- クラスに良い名前が付き、その名前がクラスの基本目標を説明しているか。
- クラスのインターフェイスは一貫性のある抽象化を実現しているか。
- クラスのインターフェイスはクラスの使用法を明確に示しているか。
- クラスのインターフェイスは、そのサービスの実装方法について考えなくてもよいほど抽象化されているか。クラスをブラックボックスとして扱うことができるか。
- 他のクラスがそのクラスの内部データに干渉する必要がないほど、クラスのサービスの完成度は高いか。
- 関係のない情報をクラスの外へ移動したか 。
- クラスをコンポ ーネントのクラスに再分割することを検討し 、それをできるだけ細かく分けてみたか 。
- クラスを修正するときにクラスのインタ ーフェイスの整合性を維持しているか 。

## カプセル化

- クラスのメンバへのアクセスを最小限に抑えているか 。
- クラスのメンバデ ータの公開を避けているか 。
- プログラミング言語が許可する範囲内で 、クラスの実装の詳細を他のクラスから隠ぺいしているか 。
- 派生クラスを含むクラスのユ ーザ ーについて憶測していないか 。
- クラスが他のクラスに依存していないか 。疎結合か 。

## 継承

- 継承を 「 i s a 」関係のモデリングにのみ使用しているか 。つまり 、派生クラスがリスコフの置換原則に準拠しているか 。
- クラスの説明文に継承方法を記載しているか 。
- 派生クラスでオ ーバ ーライド不可能なル ーチンを 「オ ーバ ーライド 」していないか 。
- 共通のインタ ーフェイス 、デ ータ 、振る舞いを継承ツリ ーのできるだけ上のレベルに移動したか 。
- 継承ツリ ーは浅めにしているか 。
- 基底クラスのすべてのメンバデ ータを p r o t e c t e d ではなく p r i v a t e で宣言しているか 。

## その他の実装問題

- クラスに含まれているメンバデ ータの数は約 7 個またはそれ以下であるか 。
- クラスから他のクラスへの直接的または間接的なル ーチン呼び出しを最小限に抑えているか 。
- クラスが絶対に必要な範囲内で他のクラスと協力しているか 。
- すべてのメンバデ ータをコンストラクタで初期化しているか 。
- シャロ ーコピ ーを作成する明確な理由がない限り 、クラスがシャロ ーコピ ーではなくディ ープコピ ーを使用する設計になっているか 。

## 言語固有の問題

- 特定のプログラミング言語について 、クラスに関連する言語固有の問題を調査したか 。

# チェックリスト 7-1 高品質なルーチン

## 全体像

- ル ーチンを作成する理由は十分か 。
- 独自のル ーチンに分割することから利益を得られるすべての部分をル ーチンに分割したか 。
- ル ーチンの名前は効果的か 。プロシ ージャに 「動詞 ＋オブジェクト 」の明確な名前を付けているか 。関数に戻り値を説明するような名前を付けているか 。
- ル ーチンの名前はル ーチンが行うことをすべて説明しているか 。
- 一般的な処理に対する命名規則を定めているか 。
- ル ーチンの凝集度は強いか 。つまり 、 1 つの機能だけをうまく行うか 。
- ル ーチンの結合度は弱いか 。つまり 、ル ーチンどうしの結び付きが少なく 、扱いやすく 、明白で 、柔軟性があるか 。
- ル ーチンの長さは 、人工的なコ ーディング標準ではなく 、その関数やロジックによって自然に決定されているか 。

## 引数の受け渡し

- ル ーチンの引数リストは 、全体として 、一貫性のあるインタ ーフェイスの抽象化を実現しているか 。
- ル ーチンの引数は 、同様のル ーチンとの一致を含め 、合理的な順序で並んでいるか 。
- インタ ーフェイスの条件が明記されているか 。
- ル ーチンの引数は 7 個以下か 。
- 入力引数はそれぞれ使用されているか 。
- 出力引数はそれぞれ使用されているか 。
- 入力引数を作業用変数として使用していないか 。
- ル ーチンが関数である場合 、考えられるすべての状況において有効な値を返すか 。

# チェックリスト 8-1 防御的プログラミング

## 全般

- ル ーチンは不正な入力デ ータから自身を保護するか 。
- アサ ーションを使って 、事前条件と事後条件を含め 、条件を文書化しているか 。
- アサ ーションの使用は絶対に発生すべきでない条件の文書化に限定しているか 。
- ア ーキテクチャや上位レベルの設計で 、エラ ーの処理方法として特定のものを指定しているか 。
- ア ーキテクチャや上位レベルの設計で 、エラ ー処理では堅牢性と正当性のどちらを優先すべきかを指定しているか 。
- バリケ ードを築いてエラ ーによる被害を食い止め 、エラ ー処理を配慮しなければならないコ ードを減らしているか 。
- コ ードにデバッグエイドを使用しているか 。
- デバッグエイドは手間をかけずにオン /オフできるような方法で導入されているか 。
- 防御的プログラミングのコ ードの量は適切か （多すぎても少なすぎてもよくない ） 。
- 開発段階でのエラ ーの見落としを防ぐために 、防御的プログラミングテクニックを採用しているか 。

## 例外

- プロジェクトで例外処理のための標準手法を定義しているか 。
- 例外に代わる方法を検討しているか 。
- エラ ーはなるべくロ ーカルで処理し 、例外をスロ ーしないようにしているか 。
- コンストラクタやデストラクタで例外をスロ ーしていないか 。
- すべての例外の抽象化レベルが 、それらをスロ ーするル ーチンにとって適切か 。
- それぞれの例外に 、その例外に関する適切な背景情報がすべて含まれているか 。
- コ ードに空の c a t c h ブロックが含まれていないか （あるいは 、空の c a t c h ブロックを使用するのが妥当であれば 、そのことが文書化されているか ） 。

## セキュリティ

- 不正なデ ータを検査するコ ードは 、バッファオ ーバ ーフロ ー 、こっそり仕込まれた S Q L コマンドや H T M L コ ード 、整数の桁あふれ 、その他の悪質な入力の試みをチェックしているか 。
- エラ ーを返すコ ードをすべてチェックしているか 。
- すべての例外をキャッチしているか 。
- エラ ーメッセ ージがシステムへの侵入を手助けするような情報を提供していないか 。

# チェックリスト 9-1 疑似コードプログラミングプロセス

- 準備が完了していることを確認したか 。
- クラスで解決する問題を定義したか 。
- 概略レベルの設計は 、クラスと各ル ーチンの良い名前が思い浮かぶほど明確なものになっているか 。
- クラスとそのル ーチンをテストする方法について考えたか 。
- 主に安定したインタ ーフェイスと理解しやすい実装という観点から 、あるいは主にリソ ースや速度の観点から 、効率について考えたか 。
- 標準ライブラリや他のコ ードライブラリに再利用可能なル ーチンやコンポ ーネントがないかどうかを調べたか 。
- 参考資料に役に立ちそうなアルゴリズムが載っていないかどうかを調べたか 。
- 詳細な擬似コ ードを使って各ル ーチンを設計したか 。
- 擬似コ ードを頭の中で検査したか 。擬似コ ードは簡単に理解できたか 。
- 設計作業に戻る必要があるような警告 （グロ ーバルデ ータの使用 、別のクラスやル ーチンの方が適していると思われる処理など ）に注意を払ったか 。
- 擬似コ ードを正確なコ ードで表したか 。
- P P P を再帰的に適用して 、必要に応じてル ーチンをより小さなル ーチンに分解したか 。
- 条件を作成するときにそれらを文書化したか 。
- 冗長なコメントを削除したか 。
- 最初の作業で満足するのではなく 、作業を何度か繰り返して最も良い方法を選択したか 。
- コ ードを隅々まで理解しているか 。コ ードは理解しやすいか 。

# チェックリスト 10-1 データの使用に関する一般論

## 変数の初期化

- ル ーチンはそれぞれ入力引数の正当性を確認しているか 。
- 変数を最初に使用する場所の近くで宣言しているか 。
- 変数を可能な限り宣言時に初期化しているか 。
- 変数の宣言と初期化を同時に行うことができない場合 、変数を最初に使用する場所の近くで初期化しているか 。
- カウンタやアキュムレ ータは正しく初期化されているか 。必要であれば 、使用するたびに再初期化されるか 。
- コ ードが繰り返し実行される場合 、変数は正しく再初期化されているか 。
- コ ードをコンパイルしてもコンパイラの警告は出力されないか （もちろん 、すべての警告オプションを有効にしているか ） 。
- 言語が暗黙の宣言を使用する場合 、それらが原因で発生する問題への対策を講じているか 。

## デ ータの使用に関するその他の問題

- すべての変数のスコ ープを最小限に抑えているか 。
- 変数の参照は 、変数の持続間隔も寿命も 、できるだけ近くにまとめているか 。
- 制御構造とデ ータ型が対応しているか 。
- 宣言された変数はすべて使用しているか 。
- すべての変数が適切なタイミングでバインドされているか 。つまり 、バインディングの先送りによる柔軟性と 、それに伴う複雑さの増加との間で 、折り合いをつけているか 。
- それぞれの変数の目的は 1 つだけか 。それぞれの変数の意味は明確か 。隠れた意味を持っていないか 。

# チェックリスト 11-1 変数の命名

## 命名全般の検討事項

- 名前は 、変数が表すものを完全かつ正確に説明しているか 。
- 名前は 、プログラミング言語の解決策ではなく 、現実世界の問題を表しているか 。
- 名前は 、その意味を解読する必要がないほど十分に長いか 。
- 計算値を修飾子として使用する場合は 、名前の末尾に追加しているか 。
- 名前には、Num ではなく Count または Index を使用しているか。

## 特殊なデ ータの命名

- ループ変数に意味のある名前を付けているか （ 3 行以上にわたる長いループやネストしたループでは、i、j、k 以外の名前を使用する）。
- すべての 「一時 」変数を意味のある名前に変更したか 。
- ブ ール変数には 、真（true）の場合にそれらの意味が明確になるような名前を付けているか。
- 列挙型の名前には、Color_Red、Color_Green、Color*Blue の Color*のように、カテゴリを表すプレフィックスまたはサフィックスが含まれているか。
- 名前付き定数には 、それらが参照する数値ではなく 、それらが表す抽象的なエンティティに由来する名前が付いているか 。

## 命名規則

- 命名規則は 、ロ ーカルデ ータ 、クラスデ ータ 、グロ ーバルデ ータを区別するものになっているか 。
- 命名規則は 、型名 、名前付き定数 、列挙型 、変数を区別するものになっているか 。
- 命名規則は 、ル ーチンへの入力専用引数を識別しない言語でも 、それらを識別できるものになっているか 。
- 命名規則は 、言語の標準的な命名規則とできるだけ整合性のとれたものになっているか 。
- 名前は読みやすく構成されているか 。

## 短い名前

- 長い名前を使用しているか （短い名前を使用する必要がある場合を除く ） 。
- たった 1 文字を省略するために省略形を使用していないか 。
- すべての単語の省略形に一貫性があるか 。
- 発音できる名前を使用しているか 。
- 読み違えたり発音を誤ったりしやすい名前を使用していないか 。
- 短い名前を変換表にまとめているか 。

## 命名の一般的な問題 ： ‥避けるべき名前

- 誤解を招きやすい名前
- 似通った意味を持つ複数の名前
- 1 、 2 文字異なるだけの複数の名前
- 同じような発音の名前
- 数字を使用する名前
- 短くするために意図的に綴りを変えた名前
- 英語で綴りを間違えやすい名前
- 標準ライブラリのル ーチン名や既定の変数名と競合する名前
- 完全に独断的な名前
- 読みにくい文字

# チェックリスト 12-1 基本的なデータ

## 数値全般

- コ ードにマジックナンバ ーを使っていないか 。
- 「 0 による除算 」エラ ーが起きる可能性はないか 。
- 型の変換は明白か 。
- 同じ式に型の異なる変数が 2 つ使われている場合 、その式は正しく評価されるか 。
- 異なる型を比較していないか 。
- プログラムをコンパイルしても警告が出ないか 。

## 整数

- 整数の除算を行う式が正しく処理されているか 。
- 整数式で整数の桁あふれが起きないか 。

## 浮動小数点数

- 大きさが極端に異なる数の加算や減算を行っていないか 。
- 丸め誤差を体系的に防いでいるか 。
- 浮動小数点数の等価を比較していないか 。

## 文字と文字列

- マジックキャラクタやマジックストリングを使っていないか 。
- 文字列への参照に 「 1 つ違い 」エラ ーの可能性はないか 。
- C で文字列へのポインタと文字配列を別々に扱っているか 。
- C で文字列を定数 + 1 の長さで宣言するという規則に従っているか 。
- 適切であれば 、 C でポインタではなく文字配列を使っているか 。
- C で文字列を null に初期化して、無限文字列を防いでいるか。
- C で strcpy()ではなく strncpy()を使っているか。strncat()と strncmp()はどうか。

## ブ ール変数

- プログラムにブ ール変数を追加して 、条件の評価を文書化しているか 。
- プログラムにブ ール変数を追加して 、条件の評価を単純にしているか 。

## 列挙型

- 名前付き定数ではなく列挙型を使って 、プログラムの可読性 、信頼性 、保守性を改善しているか 。
- ブ ール変数では true と false の意味を完全に表現できない場合、ブール変数ではなく列挙型を使っているか。
- 列挙型を使って無効な値を評価しているか 。
- 列挙型の最初の値を 「無効 」なものとして予約しているか 。

## 名前付き定数

- デ ータの宣言やループの範囲指定にマジックナンバ ーではなく名前付き定数を使っているか 。
- 名前付き定数を一貫して使っているか 。名前付き定数を使っている部分とリテラルを使っている部分が混在していないか 。

## 配列

- 配列のすべてのインデックスが配列の有効範囲内にあるか 。
- 配列への参照に 「 1 つ違い 」エラ ーの可能性はないか 。
- 多次元配列のすべての添え字が正しい順番になっているか 。
- ネストしたループにおいて 、配列の添え字として正しい変数を使ってループインデックスのクロスト ークを防いでいるか 。

## 型の作成

- 変更の可能性があるデ ータに別の型を使っているか 。
- 型の名前は 、プログラミング言語の型ではなく 、型が表す現実世界のエンティティに基づいているか 。
- 型の名前はデ ータ宣言を文書化するくらいわかりやすいものになっているか 。
- 組み込み型を再定義していないか 。
- 単に型を再定義するのではなく 、新しいクラスを作成することについて検討したか 。

# チェックリスト 13-1 特殊なデータ型の使用に関する注意事項

## 構造体

- 変数をむき出しのまま使用せず 、構造体を使って関連するデ ータをグループにまとめ 、そのグループを操作しているか 。
- 構造体を使用する代わりにクラスを作成することを検討したか 。

## グロ ーバルデ ータ

- 間違いなくグロ ーバル変数でなければならないものを除き 、すべての変数をロ ーカル変数またはクラススコ ープで宣言しているか 。
- 変数の命名規則はロ ーカルデ ータ 、クラスデ ータ 、グロ ーバルデ ータを区別するものになっているか 。
- すべてのグロ ーバルデ ータは文書化されているか 。
- コ ードにグロ ーバルデ ータもどきが含まれていないか 。つまり 、巨大なオブジェクトに何もかも詰め込んですべてのル ーチンに渡していないか 。
- グロ ーバルデ ータの操作にアクセスル ーチンを使用しているか 。
- アクセスル ーチンとデ ータをクラスにまとめているか 。
- アクセスル ーチンは元のデ ータ型の実装を隠ぺいするような抽象化を実現しているか 。
- 関連するアクセスル ーチンの抽象化レベルが統一されているか 。

## ポインタ

- ポインタの操作をル ーチンとして独立させているか 。
- ポインタの参照は有効か 。ダングリング （未解決の ）ポインタになっていないか 。
- ポインタを使用する前に 、その有効性を確認しているか 。
- ポインタが参照する変数を使用する前に 、その有効性を確認しているか 。
- ポインタを解放した後 、 n u l l に設定しているか 。
- 必要なポインタ変数を惜しみなく使用して 、コ ードを読みやすくしているか 。
- リンクリストのポインタを正しい順序で解放しているか 。
- 緊急避難用のメモリを割り当て 、メモリが不足したときにプログラムをきちんと終了できるようにしているか 。
- 他に方法がない場合の最後の手段としてポインタを使用しているか 。

# チェックリスト 14-1 ストレートなコードの構成

- コ ードはステ ートメントどうしの依存性が明白になるように書かれているか 。
- ル ーチンに依存性が明白になるような名前が付いているか 。
- 依存性が明白でないものについてはコメントで説明しているか 。
- コ ードの重要な部分が順序に依存する場合に 、状態変数を使ってそれをチェックしているか 。
- コ ードは上から下へ読めるか 。
- 関連するステ ートメントを 1 つにまとめているか 。
- 密な依存関係にあるステ ートメントをル ーチンとして独立させているか 。

# チェックリスト 15-1 条件分の使用

## if-then 文

- 正常なケ ースの実行パスは明白になっているか 。
- if-then 文の等号と不等号の分岐は正しいか。
- else 句が明記され、文書化されているか。
- else 句は正しいか。
- if 句と else 句が正しく使われているか。逆になっていないか。
- 正常なケースは else 句ではなく if 句に続いて処理されているか。

## if-then-elseif の連鎖

- 複雑な評価をブ ール関数の呼び出しでカプセル化しているか 。
- 最も出現頻度の高いケ ースを最初に評価しているか 。
- すべてのケ ースをカバ ーしているか 。
- if-then-elseif の連鎖を実装するのが最適か。case 文よりも適しているか。

## case 文

- すべてのケ ースが意味のある順序で並んでいるか 。
- 各ケ ースの処理が単純に保たれ 、必要に応じて他のル ーチンを呼び出しているか 。
- case 文は、case 文を使用するためだけに作成された仮の変数ではなく、本物の変数を評価しているか。
- default 句を正しく使っているか。
- default 句を予想外のケースの検出と報告に使っているか。
- C、C++、Java で、case 文の最後に break 文を使っているか。

# チェックリスト 16-1 ループ

## ループの選択と作成

- for ループよりも while ループが適している場合は、while ループを使用しているか。
- ループを内から外へ作成したか 。

## ループの開始

- ループに先頭から入っているか 。
- 初期化コ ードはループの直前にあるか 。
- ループが無限ループまたはイベントループである場合 、 for i = 1 to 9999 といった不器用な方法ではなく、正攻法で作成しているか。
- ループが C++、C、または Java の for ループである場合、ループヘッダーをループの制御コードだけに使用しているか。

## ループの内容

- { と } 、またはそれに相当するものを使ってループ本体を囲み 、修正ミスによる問題を防いでいるか 。
- ループ本体で何らかの処理を行っているか 。空でないか 。
- 前処理や後処理のコ ードをループの先頭または末尾にまとめているか 。
- きちんと定義されたル ーチンと同様に 、ループでただ 1 つの機能を実行しているか 。
- ループは全体を一度に参照できるくらい短いか 。
- ループのネストは 3 段階以下になっているか 。
- ループの内容が長い場合はル ーチンとして独立させているか 。
- ループが長い場合は 、特に明確に書いているか 。

## ループ変数

- ループが f o r ループである場合 、ループの内部でループ変数を勝手に書き換えていないか 。
- ループ変数をループの外側で使用せず 、ループ変数の重要な値を変数に保存しているか 。
- ループ変数に序数または列挙を使用しているか 。浮動小数点数を使っていないか 。
- ループ変数に意味のある名前を付けているか 。
- ループ変数のクロスト ークを防いでいるか 。

## ループの終了

- ループはどのような状況下でも終了するか 。
- ループで安全カウンタを使用しているか （安全カウンタの標準を定めている場合 ） 。
- ループの終了条件は明確か 。
- break 文または continue 文を使用している場合、それらは正確か。

# チェックリスト 17-1 特殊な制御構造

## return 文

- 各ル ーチンは必要なときだけ return 文を使用しているか 。
- return 文によってコ ードが読みやすくなっているか 。

## 再帰

- 再帰ル ーチンに再帰を終了するためのコ ードが含まれているか 。
- 安全カウンタを使って再帰ル ーチンの終了を保証しているか 。
- 再帰は 1 つのル ーチンに限定されているか 。
- ル ーチンの再帰の深さはプログラムのスタックサイズの制限内に収まっているか 。
- 再帰はル ーチンを実装するための最善の手段か 。単純な反復よりもよいか 。

## go-to 文

- go-to 文はあくまでも最後の手段として使用しているか 。そして 、コ ードの可読性と保守性を改善する目的でのみ使用しているか 。
- 効率を良くするために go-to 文を使用している場合 、効率がどれだけ良くなるかを測定し 、そのことを明記しているか 。
- go-to 文のラベルはル ーチンにつき 1 つに制限しているか 。
- すべての go-to 文が前方に進むか 。後方に戻るものはないか 。
- すべての go-to ラベルが使用されているか 。

# チェックリスト 18-1 テーブル駆動方式

- 複雑なロジックの代替案としてテ ーブル駆動方式を検討したか 。
- 複雑な継承構造の代替案としてテ ーブル駆動方式を検討したか 。
- テ ーブルのデ ータを外部に保存し 、実行時にそれを読み取ることで 、コ ードを変更せずにデ ータを修正することを検討したか 。
- （ a g e の例のように ）単純なインデックス配列を使ってテ ーブルに直接アクセスできない場合 、コ ードでインデックスの計算を複製するのではなく 、アクセスキ ーの計算をル ーチンとして独立させているか 。

# チェックリスト 19-1 制御構造の問題

- 論理式に 1 と 0 ではなく true と false を使っているか。
- ブール値は true、false と暗黙に比較しているか。
- 数値は評価値と明示的に比較しているか。
- 新しいブール変数を追加したり、ブール関数やデシジョンテーブルを使用したりして、式を単純にしているか。
- ブール式は肯定的に表現しているか。
- 中かっこ（{}）は対になっているか。
- コードを明確にする必要があるすべての場所に、中かっこを使っているか。
- 論理式に完全にかっこ（()）を付けているか。
- 評価は数直線の順番に書かれているか。
- Java で評価を行う場合は、それが適切であれば、「a==b」形式でなく「a.equals(b)」形式を使っているか。
- null 文は明確に使われているか。
- 深くネストしたステートメントを使っている場合は、条件の一部を再評価する、if-then-else 文または case 文に書き換える、ネストしたコードをルーチンとして独立させる、設計をよりオブジェクト指向に書き換えるといった方法で単純化しているか、あるいは他の何らかの方法で改善しているか。
- ルーチンの判定ポイントが 10 個を超える場合、それを再設計しないことを説明するのに十分な理由があるか。
