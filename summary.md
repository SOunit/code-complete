# 1. 基礎を固める

## 1. ソフトウェアコンストラクションへようこそ

### 1.4 まとめ

- ソフトウェアコンストラクションは、ソフトウェア開発の中心的なアクティビティである。
- コンストラクションは、どのプロジェクトでも必ず実行される唯一のアクティビティである。
- コンストラクションの主なアクティビティは、詳細設計、コーディング、デバッグ、統合、デベロッパーテスト（単体テスト、統合テスト）である。
- 一般に、コンストラクションは「コーディング」、「プログラミング」とも呼ばれる。
- コンストラクションの品質は、ソフトウェアの品質を大きく左右する。
- 結果として、コンストラクションの方法をどれだけ理解しているかが、どれだけ優秀なプログラマであるかを決める。これが本書のテーマである。

## 2. ソフトウェア開発への理解を深めるメタファ

### 2.5 まとめ

- メタファはヒューリスティクスであり、アルゴリズムではない。したがって、優柔不断なところが若干ある。
- メタファは、ソフトウェア開発プロセスを既知のアクティビティと関連付けることで、その理解を促進する。
- メタファには、良いものもあれば、悪いものもある。
- ソフトウェアコンストラクションを建物の建築にたとえると、入念な準備が必要であることを指摘でき、大規模なプロジェクトと小規模なプロジェクトの違いを明確にできる。
- ソフトウェア開発のプラクティスを知的道具箱の道具にたとえると、すべてのプログラマが多くの道具を持っていることと、どのような道具も万能ではないことを指摘できる。
- メタファは相互排他的ではない。目的に合ったメタファを組み合わせて利用すればよい。

## 3. 2 回測って、1 度で切る：上流工程の必要性

### 3.8 まとめ / check 3-1, 3-2, 3-3

- コンストラクションの準備における最大目標は、リスクを削減することである。準備はリスクを減らすものでなければならず、リスクを増やすものであってはならない。
- 高品質なソフトウェアを開発するには、ソフトウェア開発プロセスの初めから終わりまで、品質に配慮しなければならない。プロジェクトの早期に品質に配慮することは、プロジェクトの最後に品質に配慮した場合よりも、製品の品質に大きく影響する。
- プログラマの仕事の 1 つは、プログラミングを始める前の入念な準備の重要性を、上司や同僚に教育することである。
- プロジェクトの種類は、コンストラクションの準備に大きく影響する。たいていのプロジェクトは高い反復性を要求するが、逐次性を重視するプロジェクトもある。
- 課題定義が十分でないと、コンストラクションの際に解決すべき課題ではなく、誤った課題を解決する羽目になる。
- 要求の策定が十分でないと、課題の重要な特徴を見逃してしまうおそれがある。コンストラクションよりも後の段階で要求を変更すると、要求を早期に変更した場合の 20 ～ 100 倍のコストがかかるため、プログラミングを開始する前に要求が正しいことを確認する。
- アーキテクチャの設計が十分でないと、コンストラクションの際に、解決すべき課題は合っていても、誤った方法で解決する羽目になる。誤ったアーキテクチャに基づいて書かれたコードが増えれば増えるほど、アーキテクチャの変更に必要なコストも増える。このため、アーキテクチャが正しいことも確認しよう。
- プロジェクトにおいて、コンストラクションの準備がどのように行われたかを理解し、それに応じてコンストラクションのアプローチを選択する。

## 4. コンストラクションの重要な決断

### 4.5 まとめ / check 4-1

- どのプログラミング言語にも長所と短所がある。使用している言語の長所と短所を把握しておこう。
- プログラミングを始める前に、プログラミング規約を定める。コードが完成してしまってからでは、規約に合わせてコードを変更するのはほぼ不可能である。
- コンストラクションプラクティスの中には、特定のプロジェクトに適さないものがある。プロジェクトに最適なプラクティスを選択しよう。
- 選択したプログラミングプラクティスが、使用しているプログラミング言語への対応なのか、それともプログラミング言語によって決まってしまったのかを自問自答してみよう。言語の中でプログラミングするのではなく、言語の中へプログラミングすることを思い出そう。
- テクノロジの波のどの位置に乗っているのかによって、どういうアプローチが効果的なのか、あるいはどのアプローチが可能なのかが決まる。テクノロジの波のどこに乗っているのかを見極め、それに応じて計画や予測を調整しよう。

# 2. 高品質なコードの作成

## 5. コンストラクションにおける設計

### 5.7 まとめ / check 5-1

- ソフトウェアの鉄則は、複雑さに対処することである。これには単純さにこだわった設計が大きく貢献する。
- 単純さは一般に 2 つの方法で実現される。一度に頭に入れなければならない本質的な複雑さを最小限に抑えること。そして、偶発的な複雑さを必要以上に増やさないことである。
- 設計はヒューリスティックな作業である。1 つの手法に固執すると、創造性が失われ、プログラムも悪い影響を受ける。
- 良い設計は反復的である。さまざまな設計を繰り返し試してみるほど、最終設計は良くなる。
- 情報隠ぺいは特に価値の高い概念である。「何を隠ぺいすべきか」を自問することによって、難しい設計問題の多くが解決される。
- 本書以外にも、設計に関する興味深い情報がいろいろ提供されている。本書の見解は氷山の一角にすぎない。

## 6. クラスの作成

### 6.8 まとめ / check 6-1

- クラスインターフェイスは一貫性のある抽象化を実現しなければならない。このたった 1 つの原則に違反しただけで、多くの問題が生じる。
- クラスインターフェイスは何か（システムインターフェイス、設計上の決断、または実装の詳細）を隠ぺいしなければならない。
- 「is a」関係をモデリングする場合を除き、通常は継承よりも包含の方が望ましい。
- 継承は便利なツールだが、複雑さを増大させる。このことは、ソフトウェアの鉄則である複雑さへの対処を妨げる。
- クラスは複雑さに対処するための第一のツールである。クラスの目標を達成するために必要なものと同じくらい、クラスの設計にも注意を払うこと。

## 7. 高品質なルーチン

### 7.8 まとめ / check 7-1

- ルーチンを作成する最も重要な理由は、プログラムを頭で理解しやすくすることである。ルーチンを作成する正当な理由は他にもいろいろある。スペースを節約することは、理由としてあまり重要でない。可読性、信頼性、保守性の方が重要である。
- ルーチンとして独立させることが最も効果的なのは、単純な処理である。
- ルーチンは凝集度という観点から何種類かに分類できる。ただし、ほとんどのルーチンは機能的凝集度を持っており、それが最も望ましい。
- ルーチンの名前はその品質を表す。名前は悪いが、ルーチンの目的を正確に表しているとしたら、ルーチンの設計が良くないのかもしれない。名前が悪く、ルーチンの目的も正確に表していないとしたら、プログラムが何をするのかを名前が伝えていない。いずれにしても、悪い名前はプログラムを変更する必要があることを意味する。
- 関数を使用するのは、関数の主目的が関数名で説明される特定の値を返すことである場合だけにすべきである。
- 慎重なプログラマは、マクロルーチンの使用に注意し、最後の手段としてのみ使用する。

## 8. 防御的プログラミング

### 8.10 まとめ / check 8-1

- 製品版のコードでは、「ごみ入れ、ごみ出し」よりも洗練された方法で、エラーを処理すべきである。
- 防御的プログラミングテクニックは、エラーの検出と修正を容易にし、製品版のコードへの被害を食い止める。
- 特に大規模なシステム、高い信頼性が要求されるシステム、変化の速いコードベースでは、アサーションはエラーを早期に検出するのに役立つ。
- 不正な入力に対処する方法を決定することは、エラー処理においても上位レベルの設計においても重要な決断である。
- 例外は、コードの正常な流れとは別の次元で、エラー処理を実行するための手段となる。慎重に使用すれば、例外はプログラマの知的な道具箱になくてはならないツールとなるが、他のエラー処理テクニックと比較検討すべきである。
- 製品版のシステムに適用される制約を開発バージョンのシステムに適用する必要はない。開発バージョンは自分の都合の良いように使用することができ、エラーをすばやく暴き出すためのコードを追加してもかまわない。

## 9. 疑似コードによるプログラミング

### 9.5 まとめ / check 9-1

- クラスやルーチンの作成は、反復型のプロセスであることが多い。特定のルーチンを作成している最中に得られた洞察力は、クラスの設計に活かされることが多い。
- 良い擬似コードを書くには、わかりやすい文章を使い、特定のプログラミング言語に固有の機能を避け、目的のレベルで書く必要がある（目的は、その設計が何を行うのかを説明することであって、それを行う方法を説明することではない）。
- PPP は、詳細設計のための便利なツールであり、コーディングを容易にする。擬似コードはそのままコメントになるため、正確かつ効果的なコメントが得られる。
- 最初に思い付いた設計で満足しないこと。コーディングに取りかかる前に、擬似コードを使って複数の方法を試し、最も良い方法を選ぶ。
- 段階ごとにそこでの成果物を確認し、第三者にも確認してもらう。そうすれば、まだ労力をそれほど注ぎ込んでいない最も安価な段階で、ミスを捕らえることができる。

# 3. 変数

## 10. 変数の使用

### 10.9 まとめ / check 10-1

- データの初期化はエラーの原因になりやすいので、本章で説明した初期化のテクニックを利用して、予想外の初期値による問題を未然に防ぐ。
- 変数のスコープは最小限に抑える。変数の参照を近くに集める。変数はルーチンまたはクラスのローカル変数にする。グローバルデータを使用しない。
- 同じ変数を扱うステートメントが複数ある場合は、それらをできるだけ近くにまとめる。
- 早期のバインディングは柔軟性を制限するが、複雑さを最小限に抑える。バインディングを先送りすると柔軟性は高まるが、その分複雑さが増す。
- 変数はそれぞれ 1 つの目的に使用する。

## 11. 変数名の力

### 11.8 まとめ / check 11-1

- プロジェクトの種類にかかわらず 、変数の命名規則を採用すること 。どのような命名規則を採用するかは 、プログラムのサイズやプロジェクトに従事している人数によって決まる 。
- 最近のプログラミング言語で省略形が必要になることはまれである 。それでも省略形を使用するという場合は 、省略形をプロジェクトの辞書に記録するか 、標準化されたプレフィックスを使用する 。
- コ ードは書くことよりも読むことの方がずっと多い 。名前を付ける際には 、書き手の便宜ではなく読み手の便宜を優先すること 。
- 良い変数名は 、プログラムの読みやすさの鍵を握る要素である 。ル ープ変数や状態変数といった特殊な変数には 、特に注意する必要がある 。
- 名前はできるだけ具体的なものにする 。複数の目的に使用されるようなあいまいな名前や一般的な名前は 、通常は悪い名前である 。
- 命名規則で 、ロ ーカルデ ータ 、クラスデ ータ 、グロ ーバルデ ータを区別する 。また 、型名 、名前付き定数 、列挙型 、変数も区別する 。

## 12. 基本的なデータ型

### 12.10 まとめ / check 12-1

- 特定のデ ータ型を使用することは 、型に固有のさまざまな規則を覚えておくことを意味する 。本章のチェックリストを使って 、一般的な問題について検討したかどうかを確認しよう 。
- ユ ーザ ー定義型を作成すると 、プログラムが変更しやすくなり 、読めばわかるものになる 。ただし 、使用している言語がユ ーザ ー定義型に対応していることが前提となる 。
- typedef やそれに相当する機能を使って単純な型を作成する場合は 、代わりに新しいクラスを作成すべきかどうかについて検討しよう 。

## 13. 特殊なデータ型

### 13.5 まとめ / check 13-1

- 構造体は 、プログラムの複雑さを和らげ 、プログラムを理解しやすく保守しやすいものにする 。
- 構造体を使用するかどうかについて検討する場合は 、それによってクラスの動作が良くなるかどうかを考える 。
- ポインタはエラ ーの原因になりやすい 。アクセスル ーチンやクラス 、防御的プログラミングを使って自衛する 。
- グロ ーバル変数を使用しない 。単にリスクがあるからという理由だけでなく 、他にもっと良い方法があるからだ 。
- グロ ーバル変数を使用せざるを得ない場合は 、アクセスル ーチンを使って操作する 。アクセスル ーチンを使用すれば 、グロ ーバル変数のすべての利点以上のものが得られる 。

# 4. ステートメント

## 14. ストレートなコードの構成

### 14.3 まとめ / check 14-1

- コ ードをストレ ートなものにする原則として最も重視されるのは 、実行順序への依存性である 。
- 依存性は 、良いル ーチン名 、引数リスト 、コメントなどを使って明白にすべきである 。コ ードがきわめて重要なものである場合は 、状態変数を使用する 。
- コ ードが実行順序に依存しない場合は 、関連するステ ートメントをできるだけ近くにまとめる 。

## 15. 条件文の使用

### 15.3 まとめ / check 15-1

- 単純な if-else 文では 、それらがエラ ーをいくつも処理する場合は特に 、 if 句と else 句の順番に注意する 。正常なケ ースが明白であることを確認する 。
- if-then-else の連鎖と case 文は 、最も読みやすい順番に並べる 。
- case 文の default 句か 、 if-then-else 文の最後の else 句を使って 、エラーを捕捉する 。
- 制御構造の作りはどれも同じではない 。各コードブロックに最適な制御構造を選択する。

## 16. ループの制御

### 16.5 まとめ / check 16-1

- ル ープは複雑である 。ル ープを単純に保つことは 、コ ードの読み手の助けになる 。
- ル ープを単純に保つコツは 、変わったル ープを作成しない 、ネストをできるだけ少なくする 、入口と出口を明確にする 、前処理や後処理のコ ードを 1 か所にまとめる 、といったことが挙げられる 。
- ル ープ変数ほど誤用されるものはない 。ル ープ変数にはわかりやすい名前を付け 、 1 つの目的にのみ使用する 。
- ル ープ全体を入念に検討し 、すべてのケ ースで正常に実行されることと 、どのような条件でも終了することを検証する 。

## 17. 特殊な制御構造

### 17.6 まとめ / check 17-1

- 複数の r e t u r n 文は 、ル ーチンの可読性と保守性を向上させ 、深くネストしたロジックを避けるのに役立つ 。それでも 、慎重に使用すべきである 。
- 再帰は 、問題の範囲が狭い場合の的確な解決策となる 。これも慎重に使用すること 。
- 可読性と保守性の良いコ ードを書くために 、 g o t o 文が最善の方法となるケ ースがいくつかある 。しかし 、そのようなケ ースはまれである 。 g o t o 文はあくまでも最後の手段として使用する 。

## 18. テーブル駆動方式

### 18.6 まとめ / check 18-1

- テ ーブルは 、複雑なロジックや継承構造に代わる手段を提供する 。プログラムのロジックや継承ツリ ーで頭が混乱するような場合は 、参照テ ーブルを使って単純にできるかどうか検討する 。
- テ ーブルを使用するうえで重要となるのは 、テ ーブルにアクセスする方法を決定することである 。テ ーブルにアクセスする方法には 、直接アクセス 、インデックスアクセス 、段階型アクセスがある 。
- テ ーブルを使用するうえでもう 1 つ重要なのは 、テ ーブルに保存するものを正確に決定することである 。

## 19. 制御構造の問題

### 19.7 まとめ / check 19-1

- 論理式を単純で読みやすいものにすることは、コードの品質に大きく貢献する。
- 深いネストはルーチンの理解を妨げる。さいわい、この問題は比較的簡単に防ぐことができる。
- 構造化プログラミングは、今でもその価値を失っていないシンプルな概念である。どのようなプログラムも、連続、選択、反復の組み合わせで作成することができる 。
- 複雑さを最小限に抑えることは 、高品質なコ ードを書くための鍵である 。

# 5. コードの改良

## 20. ソフトウェアの品質

### 20.7 まとめ

- 品質は最終的にタダになるが、安価な欠陥の予防で高価な欠陥の修正を避けるためには、リソースの再配分が必要である。
- すべての品質保証目標を同時に達成できるとは限らない。どの目標を達成したいのかをはっきり決めて、チームの他のメンバに知らせること。
- どの欠陥検出テクニックも、単独ではその威力を発揮しない。テストだけでは、エラーの排除に関して最大の効果は得られない。効果的な品質保証プログラムは、数種類のテクニックを組み合わせてさまざまなエラーを検出する。
- 効果的なテクニックはコンストラクション時に適用できるし、同じく強力なさまざまなテクニックをコンストラクションの前に適用できる。欠陥は検出が早ければ早いほど、コードの陰に隠れることが少なくなり、それによる損害も少なくなる。
- ソフトウェア分野の品質保証はプロセス指向である。ソフトウェア開発は製造業と異なり、最終的な製品を左右する反復的な工程がない。したがって、ソフトウェアを開発するためのプロセスが最終的な製品の品質を決定する。

## 21. コラボレーティブコンストラクション

- コラボレーティブ開発プラクティスは、テストよりも高い割合で、より効果的に欠陥を検出する傾向がある。
- コラボレーティブ開発プラクティスは、テストとは異なる種類のエラーを検出する傾向がある。つまり、ソフトウェアの品質を保証するためには、レビューとテストの両方を使用する必要がある。
- 公式なインスペクションでは、エラーをできるだけ効率よく検出するために、チェックリスト、準備、明確な役割、継続的なプロセス改善が必要である。インスペクションでは、一般にウォークスルーよりも多くの欠陥が検出される。
- ペアプログラミングは一般にインスペクションと同じ程度のコストがかかり、同じような品質のコードを生み出す。ペアプログラミングはスケジュールの短縮が望まれるときに威力を発揮する。 1 人で作業するよりも、ペアで作業することを好む開発者もいる。
- 公式なインスペクションは、コードだけでなく、要求、設計、テストケースなどの作業にも利用できる。
- ウォークスルーとコードリーディングはインスペクションの代替手段である。コードリーディングは、参加者の時間を効率良く使用する点で、柔軟性に優れている。

## 22. デベロッパーテスト

- 開発者によるテストは、本格的なテスト戦略において重要な位置を占める（独立テストも重要だが、本書では取り上げない）。
- コードよりも先にテストケースを書くと、テストケースよりも先にコードを書く場合と時間や労力は変わらないが、欠陥検出/修正サイクルは短くなる。
- 利用できるテストはさまざまだが、テストは優れたソフトウェア品質改善プログラムの一部にすぎない。要求や設計の欠陥を最小限に抑えるといった高品質な開発手法も同じくらい重要である。コラボレーティブ開発プラクティスも、エラーの検出という点ではテストと同じくらい効果的である。そして、これらのプラクティスはテストとは異なる種類のエラーを検出する。
- 基礎テスト、データフロー分析、境界分析、悪いデータ、良いデータを基に、多くのテストケースを確実に生成することができる。エラーの推測を基に、さらにテストケースを生成することができる。
- エラーはエラーを発生しやすい一部のクラスやルーチンに集中する傾向にある。エラーを発生しやすいコードを突き止め、設計を見直し、書き直すこと。
- テストデータにはテスト対象のコードよりもエラーが紛れ込みやすい。このようなエラーを追いかけていると、コードが改善されないまま時間がどんどん過ぎていくので、テストデータのエラーはプログラミングエラーよりもやっかいである。テストをコードと同じくらい慎重に作成して、こうしたエラーを防ぐこと。
- 自動テストは一般に便利であり、回帰テストに欠かせない。
- 長い目で見れば、テストプロセスを改善する最も良い方法は、テストを日常化し、評価し、それを改善するための手法を用いることである。

## 23. デバッグ

- デバッグは、ソフトウェア開発の成否を握る部分である。本書の他の部分で解説するテクニックを使って、欠陥を最初から持ち込まないことが望ましい。ただし、それでもデバッグの腕に磨きをかける価値はある。良いデバッグと悪いデバッグでは、パフォーマンスに 10 対 1 もの開きがあるからだ。
- 欠陥の検出と修正を体系的に行うことが成功の鍵である。すべてのテストが一歩前進となるよう、デバッグに集中する。科学的なデバッグを行う。
- 問題を修正する前に、根本的な問題を理解する。エラーの原因に対する当て推量と行き当たりばったりの修正は、プログラムの状態をますます悪化させるだけである。
- コンパイラの警告レベルを最も敏感なレベルにして、報告されたエラーを修正する。目立つものを無視していたのでは、目立たないものはとても修正できない。
- デバッグツールはソフトウェア開発を強力に支援する。それらを探して使用すると同時に、頭を使うことを忘れない。

## 24. リファクタリング

- プログラムの変更は、最初の開発時と最初のリリース後の両方において、避けがたい事実である。
- ソフトウェアは、変更によって改良されることもあれば、後退することもある。コードの進化に伴って内部品質を改善することが、ソフトウェアの進化の鉄則である。
- リファクタリングを成功させる 1 つの鍵は、リファクタリングの必要性を示すさまざまな警告のサインやにおいに注意することだ。
- リファクタリングを成功させるもう 1 つの鍵は、さまざまなリファクタリングの方法を知ることである。
- リファクタリングを成功させる最後の鍵は、安全確実にリファクタリングを行うための戦略を練ることである。状況に適したリファクタリング手法を選択する。
- 開発時のリファクタリングは、プログラムを改善し、最初に済ませておきたいすべての変更を行う絶好のチャンスである。開発中のこうした機会を逃さないようにする。

## 25. コードチューニング戦略

- パフォーマンスは、ソフトウェアの全体的な品質の 1 つの側面にすぎない。そして、通常は最も重要なものではない。正しくチューニングされたコードは全体的なパフォーマンスの 1 つの側面にすぎず、通常は最も重大なものではない。通常はプログラムのアーキテクチャ、詳細設計、およびデータ構造とアルゴリズムの選択の方が、プログラムのコードの効率よりもプログラムの実行速度とサイズに大きな影響を及ぼす。
- 具体的な量を測定することは、パフォーマンスを最大にするための鍵である。測定は、パフォーマンスの改善に価値がある領域を見つけるために必要であり、最適化がソフトウェアのパフォーマンスを向上させ、低下させていないことを確認するためにも必要である。
- ほとんどのプログラムでは、ほんの一部のコードが実行時間のほとんどを占める。どれがそのコードなのかは測定してみなければわからない。
- コードチューニングを通じてパフォーマンス目標を達成するには、通常は作業を何度か繰り返すことが必要である。
- 最初のコーディング時にパフォーマンスの改善作業の準備を整えるとしたら、理解しやすく変更しやすいすっきりとしたコードを書くのが一番効果的である。

## 26. コードチューニングテクニック

- 最適化の結果は、言語、コンパイラ、環境の違いに大きく左右される。個々の最適化を測定しなければ、それがプログラムを改善するのか改悪するのかはわからない。
- 1 つ目の最適化は最善のものではない場合が多い。良い最適化を見つけた後も、他にもっと良い最適化がないか探し続けること。
- コードチューニングは原子力のようなもので、議論の分かれる感情的なテーマである。信頼性や保守性にきわめて有害なので、まったく実行するつもりはないという意見もあれば、それは正しい安全対策であり、効果的であるという意見もある。本章で紹介したテクニックを使うことにした場合は、くれぐれも注意して適用するように。

## 27. プログラムサイズが及ぼす影響

- プロジェクトの規模が大きくなるにつれ、コミュニケーションをサポートする必要が生じる。ほとんどの方法論のポイントは、コミュニケーションの問題を軽減することである。コミュニケーションの促進にどれくらい貢献するかが、方法論が有効かどうかの分かれ目となる。
- 他の条件がすべて同じであるとすれば、大規模なプロジェクトは小規模なプロジェクトよりも生産性が低い。
- 他の条件がすべて同じであるとすれば、 1, 000 行あたりのエラーの数は、大規模なプロジェクトの方が小規模なプロジェクトよりも多い。
- 小規模なプロジェクトでは当たり前の作業も、大規模なプロジェクトでは注意してかかる必要がある。プロジェクトの規模が大きくになるにつれ、コンストラクションの占める割合は少なくなる。
- 軽量な方法論を拡張する方が重量な方法論を縮小するよりもうまくいく。最も効果的なアプローチは「正しい分量」の方法論を採用することだ。

## 28. コンストラクションの管理

- 良いコーディングプラクティスは、標準またはそれに準じるアプローチを通じて達成することができる。
- 構成管理を正しく適用すれば、プログラマの作業が楽になる。これには変更管理も含まれる。
- ソフトウェアの正しい見積もりは難題の 1 つである。成功のポイントは、複数の方法を試し、プロジェクトを進めながら見積もりを正確なものにしていき、データに基づいて見積もりを作成することである。
- 測定はコンストラクションをうまく管理するための鍵を握っている。プロジェクトをまったく測定しないより、測定した方がよい部分が必ず見つかるはずだ。正確なスケジュール、品質管理、開発プロセスの向上には、正確な測定が欠かせない。
- プログラマと管理者は人間である。それを意識すればうまくいく。

## 29. 統合

- コンストラクションの手順と統合手法は、クラスの設計、コーディング、テストの順序に影響する。
- 統合の順序を熟慮すると、テスト作業が少なくなり、デバッグが容易になる。
- インクリメンタル型の統合にはいくつかの種類がある。プロジェクトが小さなものでない限り、フェーズ型の統合よりもインクリメンタル型の統合の方が効果的である。
- プロジェクトにとって最適な統合手法は、通常、トップダウン、ボトムアップ、リスク指向、その他の統合手法を組み合わせたものである。 T 字型統合と垂直スライス統合はうまくいくことが多い。
- デイリービルドは、統合の問題を減らし、開発者の士気を高め、プロジェクトマネジメントの情報を把握しやすくする。

## 30. プログラミングツール

- コンストラクションの手順と統合手法は、クラスの設計、コーディング、テストの順序に影響する。
- 統合の順序を熟慮すると、テスト作業が少なくなり、デバッグが容易になる。
- インクリメンタル型の統合にはいくつかの種類がある。プロジェクトが小さなものでない限り、フェーズ型の統合よりもインクリメンタル型の統合の方が効果的である。
- プロジェクトにとって最適な統合手法は、通常、トップダウン、ボトムアップ、リスク指向、その他の統合手法を組み合わせたものである。 T 字型統合と垂直スライス統合はうまくいくことが多い。
- デイリービルドは、統合の問題を減らし、開発者の士気を高め、プロジェクトマネジメントの情報を把握しやすくする。

## 31. レイアウトとスタイル

- 視覚的なレイアウトの最優先事項は、コードの論理構造を浮き彫りにすることである。これが達成されたかどうかの判断基準としては、正確性、一貫性、可読性、保守性が挙げられる。
- 体裁の良さは、他の条件の次である。しかも、それらの間にはかなりの隔たりがある。ただし、他の条件が満たされていて、ベースのコードが良いものであれば、レイアウトは体裁良く見える。
- Visual Basic は純粋なブロックを持ち、 Java では伝統的に純粋なブロックスタイルを使用するため、これらの言語でプログラムする場合は、「純粋なブロック」レイアウトを使用することができる。 C ++では、「純粋なブロックのエミュレーション」スタイルか、「 begin-end によるブロック境界の指定」スタイルを使用すると効果的である。
- コードの構造化はそのものが重要である。どの規約に従うかではなく、何らかの規約に一貫して従うことの方が重要だ。レイアウトの規約に一貫して従わないと、かえって読みやすさを損なうことになる。
- レイアウトには宗教的な側面がいろいろある。主観的な好みと客観的な好みを切り離して考えよう。明示的な基準をどのスタイルが良いかについて話し合うためのたたき台にしよう。

## 32. 読めばわかるコード

- コメントを付けるかどうかは重要な問題である。ひどいコメントを付けるのは時間の無駄であり、害となることもある。良いコメントを付けることには価値がある。
- ソースコードには、プログラムに関する重要な情報のほとんどが含まれていなければならない。プログラムが実行されている限り、ソースコードは他のどのリソースよりも最新の状態に保たれる可能性が高いので、重要な情報はコードにまとめておくと効果的である。
- 良いコードはそれ自体が最高のドキュメントである。何もかもコメントで説明しなければならないほどコードが良くない場合は、コードをコメントだらけにする必要がないように、まずコード自体を改善すること。
- コメントは、コードでは言い表せないコードの何かを、概要または意図のレベルで説明するものにする。
- コメントスタイルによっては、単調で機械的な作業を延々と繰り返さなければならないものがある。保守作業が容易になるようなスタイルを作成しよう。

## 33. 個人の資質

- 個人の資質は、コンピュータプログラムを書く能力に直接影響する。
- 最も重要な資質は、謙虚さ、好奇心、知的な誠実さ、創造性と規律、そして啓発的な怠惰である。
- 優秀なプログラマの資質は、才能とはほとんど関係がなく、すべて個人の成長への意欲によるものである。
- 意外にも、未熟な知性、経験、粘り強さ、根気は、助けになることもあれば、害になることもある。
- 多くのプログラマは、新しい情報や技術を積極的に求めず、実際に仕事をしながら新しい情報が偶然に手に入ることをあてにしている。プログラミングに関する文献を読んで学ぶことに少し時間を割けば、数か月または数年後に、あなたはその他大勢のプログラマの中から大きく頭角を現していることだろう。
- 良い資質は、正しい習慣を身につけているかどうかによるところが大きい。偉大なプログラマを目指すなら、良い習慣を身につけること。そうすれば、残りは自然とついてくる。

## 34. ソフトウェア職人気質とは

- プログラミングの主な目標の 1 つは、複雑さに対処することである。
- プログラミングプロセスは、最終的な製品に大きく影響する。
- チームプログラミングでは、コンピュータとのコミュニケーションよりも、人とのコミュニケーションが大切である。個々のプログラミングでは、コンピュータとのコミュニケーションよりも、自分自身とのコミュニケーションに終始する。
- プログラミング規約は、使い方を誤ると、病気よりもたちの悪い薬となる可能性がある。よく考えて使用すれば、プログラミング規約は開発環境に有益な構造をもたらし、複雑さの克服や意思の疎通に役立つ。
- 解決策ではなく問題の観点でプログラミングすることは、複雑さの克服に役立つ。
- プログラミングはほぼ完全に知的なアクティビティなので、「疑いの炎症」のような知的な危険信号に注意を払うことは、プログラミングでは特に重要である。
- 各開発アクティビティを反復すればするほど、そのアクティビティの成果は良いものになる。
- 独断的な手法と高品質なソフトウェア開発は相容れない。知的な道具箱にプログラミングの代替道具をぎっしりと詰め込み、作業に適した道具を選択する能力に磨きをかけよう。
