# 1. 基礎を固める

## 1. ソフトウェアコンストラクションへようこそ

### 1.4 まとめ

- ソフトウェアコンストラクションは、ソフトウェア開発の中心的なアクティビティである。
- コンストラクションは、どのプロジェクトでも必ず実行される唯一のアクティビティである。
- コンストラクションの主なアクティビティは、詳細設計、コーディング、デバッグ、統合、デベロッパーテスト（単体テスト、統合テスト）である。
- 一般に、コンストラクションは「コーディング」、「プログラミング」とも呼ばれる。
- コンストラクションの品質は、ソフトウェアの品質を大きく左右する。
- 結果として、コンストラクションの方法をどれだけ理解しているかが、どれだけ優秀なプログラマであるかを決める。これが本書のテーマである。

## 2. ソフトウェア開発への理解を深めるメタファ

### 2.5 まとめ

- メタファはヒューリスティクスであり、アルゴリズムではない。したがって、優柔不断なところが若干ある。
- メタファは、ソフトウェア開発プロセスを既知のアクティビティと関連付けることで、その理解を促進する。
- メタファには、良いものもあれば、悪いものもある。
- ソフトウェアコンストラクションを建物の建築にたとえると、入念な準備が必要であることを指摘でき、大規模なプロジェクトと小規模なプロジェクトの違いを明確にできる。
- ソフトウェア開発のプラクティスを知的道具箱の道具にたとえると、すべてのプログラマが多くの道具を持っていることと、どのような道具も万能ではないことを指摘できる。
- メタファは相互排他的ではない。目的に合ったメタファを組み合わせて利用すればよい。

## 3. 2 回測って、1 度で切る：‥上流工程の必要性

### 3.8 まとめ / check 3-1, 3-2, 3-3

- コンストラクションの準備における最大目標は、リスクを削減することである。準備はリスクを減らすものでなければならず、リスクを増やすものであってはならない。
- 高品質なソフトウェアを開発するには、ソフトウェア開発プロセスの初めから終わりまで、品質に配慮しなければならない。プロジェクトの早期に品質に配慮することは、プロジェクトの最後に品質に配慮した場合よりも、製品の品質に大きく影響する。
- プログラマの仕事の 1 つは、プログラミングを始める前の入念な準備の重要性を、上司や同僚に教育することである。
- プロジェクトの種類は、コンストラクションの準備に大きく影響する。たいていのプロジェクトは高い反復性を要求するが、逐次性を重視するプロジェクトもある。
- 課題定義が十分でないと、コンストラクションの際に解決すべき課題ではなく、誤った課題を解決する羽目になる。
- 要求の策定が十分でないと、課題の重要な特徴を見逃してしまうおそれがある。コンストラクションよりも後の段階で要求を変更すると、要求を早期に変更した場合の 20 ～ 100 倍のコストがかかるため、プログラミングを開始する前に要求が正しいことを確認する。
- アーキテクチャの設計が十分でないと、コンストラクションの際に、解決すべき課題は合っていても、誤った方法で解決する羽目になる。誤ったアーキテクチャに基づいて書かれたコードが増えれば増えるほど、アーキテクチャの変更に必要なコストも増える。このため、アーキテクチャが正しいことも確認しよう。
- プロジェクトにおいて、コンストラクションの準備がどのように行われたかを理解し、それに応じてコンストラクションのアプローチを選択する。

## 4. コンストラクションの重要な決断

### 4.5 まとめ / check 4-1

- どのプログラミング言語にも長所と短所がある。使用している言語の長所と短所を把握しておこう。
- プログラミングを始める前に、プログラミング規約を定める。コードが完成してしまってからでは、規約に合わせてコードを変更するのはほぼ不可能である。
- コンストラクションプラクティスの中には、特定のプロジェクトに適さないものがある。プロジェクトに最適なプラクティスを選択しよう。
- 選択したプログラミングプラクティスが、使用しているプログラミング言語への対応なのか、それともプログラミング言語によって決まってしまったのかを自問自答してみよう。言語の中でプログラミングするのではなく、言語の中へプログラミングすることを思い出そう。
- テクノロジの波のどの位置に乗っているのかによって、どういうアプローチが効果的なのか、あるいはどのアプローチが可能なのかが決まる。テクノロジの波のどこに乗っているのかを見極め、それに応じて計画や予測を調整しよう。

# 2. 高品質なコードの作成

## 5. コンストラクションにおける設計

### 5.7 まとめ / check 5-1

- ソフトウェアの鉄則は、複雑さに対処することである。これには単純さにこだわった設計が大きく貢献する。
- 単純さは一般に 2 つの方法で実現される。一度に頭に入れなければならない本質的な複雑さを最小限に抑えること。そして、偶発的な複雑さを必要以上に増やさないことである。
- 設計はヒューリスティックな作業である。1 つの手法に固執すると、創造性が失われ、プログラムも悪い影響を受ける。
- 良い設計は反復的である。さまざまな設計を繰り返し試してみるほど、最終設計は良くなる。
- 情報隠ぺいは特に価値の高い概念である。「何を隠ぺいすべきか」を自問することによって、難しい設計問題の多くが解決される。
- 本書以外にも、設計に関する興味深い情報がいろいろ提供されている。本書の見解は氷山の一角にすぎない。

## 6. クラスの作成

### 6.8 まとめ / check 6-1

- クラスインターフェイスは一貫性のある抽象化を実現しなければならない。このたった 1 つの原則に違反しただけで、多くの問題が生じる。
- クラスインターフェイスは何か（システムインターフェイス、設計上の決断、または実装の詳細）を隠ぺいしなければならない。
- 「is a」関係をモデリングする場合を除き、通常は継承よりも包含の方が望ましい。
- 継承は便利なツールだが、複雑さを増大させる。このことは、ソフトウェアの鉄則である複雑さへの対処を妨げる。
- クラスは複雑さに対処するための第一のツールである。クラスの目標を達成するために必要なものと同じくらい、クラスの設計にも注意を払うこと。

## 7. 高品質なルーチン

### 7.8 まとめ / check 7-1

- ルーチンを作成する最も重要な理由は、プログラムを頭で理解しやすくすることである。ルーチンを作成する正当な理由は他にもいろいろある。スペースを節約することは、理由としてあまり重要でない。可読性、信頼性、保守性の方が重要である。
- ルーチンとして独立させることが最も効果的なのは、単純な処理である。
- ルーチンは凝集度という観点から何種類かに分類できる。ただし、ほとんどのルーチンは機能的凝集度を持っており、それが最も望ましい。
- ルーチンの名前はその品質を表す。名前は悪いが、ルーチンの目的を正確に表しているとしたら、ルーチンの設計が良くないのかもしれない。名前が悪く、ルーチンの目的も正確に表していないとしたら、プログラムが何をするのかを名前が伝えていない。いずれにしても、悪い名前はプログラムを変更する必要があることを意味する。
- 関数を使用するのは、関数の主目的が関数名で説明される特定の値を返すことである場合だけにすべきである。
- 慎重なプログラマは、マクロルーチンの使用に注意し、最後の手段としてのみ使用する。

## 8. 防御的プログラミング

### 8.10 まとめ / check 8-1

- 製品版のコードでは、「ごみ入れ、ごみ出し」よりも洗練された方法で、エラーを処理すべきである。
- 防御的プログラミングテクニックは、エラーの検出と修正を容易にし、製品版のコードへの被害を食い止める。
- 特に大規模なシステム、高い信頼性が要求されるシステム、変化の速いコードベースでは、アサーションはエラーを早期に検出するのに役立つ。
- 不正な入力に対処する方法を決定することは、エラー処理においても上位レベルの設計においても重要な決断である。
- 例外は、コードの正常な流れとは別の次元で、エラー処理を実行するための手段となる。慎重に使用すれば、例外はプログラマの知的な道具箱になくてはならないツールとなるが、他のエラー処理テクニックと比較検討すべきである。
- 製品版のシステムに適用される制約を開発バージョンのシステムに適用する必要はない。開発バージョンは自分の都合の良いように使用することができ、エラーをすばやく暴き出すためのコードを追加してもかまわない。

## 9. 疑似コードによるプログラミング

### 9.5 まとめ / check 9-1

- クラスやルーチンの作成は、反復型のプロセスであることが多い。特定のルーチンを作成している最中に得られた洞察力は、クラスの設計に活かされることが多い。
- 良い擬似コードを書くには、わかりやすい文章を使い、特定のプログラミング言語に固有の機能を避け、目的のレベルで書く必要がある（目的は、その設計が何を行うのかを説明することであって、それを行う方法を説明することではない）。
- PPP は、詳細設計のための便利なツールであり、コーディングを容易にする。擬似コードはそのままコメントになるため、正確かつ効果的なコメントが得られる。
- 最初に思い付いた設計で満足しないこと。コーディングに取りかかる前に、擬似コードを使って複数の方法を試し、最も良い方法を選ぶ。
- 段階ごとにそこでの成果物を確認し、第三者にも確認してもらう。そうすれば、まだ労力をそれほど注ぎ込んでいない最も安価な段階で、ミスを捕らえることができる。

# 3. 変数

## 10. 変数の使用

### 10.9 まとめ / check 10-1

- データの初期化はエラーの原因になりやすいので、本章で説明した初期化のテクニックを利用して、予想外の初期値による問題を未然に防ぐ。
- 変数のスコープは最小限に抑える。変数の参照を近くに集める。変数はルーチンまたはクラスのローカル変数にする。グローバルデータを使用しない。
- 同じ変数を扱うステートメントが複数ある場合は、それらをできるだけ近くにまとめる。
- 早期のバインディングは柔軟性を制限するが、複雑さを最小限に抑える。バインディングを先送りすると柔軟性は高まるが、その分複雑さが増す。
- 変数はそれぞれ 1 つの目的に使用する。

## 11. 変数名の力

### 11.8 まとめ / check 11-1

- プロジェクトの種類にかかわらず 、変数の命名規則を採用すること 。どのような命名規則を採用するかは 、プログラムのサイズやプロジェクトに従事している人数によって決まる 。
- 最近のプログラミング言語で省略形が必要になることはまれである 。それでも省略形を使用するという場合は 、省略形をプロジェクトの辞書に記録するか 、標準化されたプレフィックスを使用する 。
- コ ードは書くことよりも読むことの方がずっと多い 。名前を付ける際には 、書き手の便宜ではなく読み手の便宜を優先すること 。
- 良い変数名は 、プログラムの読みやすさの鍵を握る要素である 。ル ープ変数や状態変数といった特殊な変数には 、特に注意する必要がある 。
- 名前はできるだけ具体的なものにする 。複数の目的に使用されるようなあいまいな名前や一般的な名前は 、通常は悪い名前である 。
- 命名規則で 、ロ ーカルデ ータ 、クラスデ ータ 、グロ ーバルデ ータを区別する 。また 、型名 、名前付き定数 、列挙型 、変数も区別する 。

## 12. 基本的なデータ型

### 12.10 まとめ / check 12-1

- 特定のデ ータ型を使用することは 、型に固有のさまざまな規則を覚えておくことを意味する 。本章のチェックリストを使って 、一般的な問題について検討したかどうかを確認しよう 。
- ユ ーザ ー定義型を作成すると 、プログラムが変更しやすくなり 、読めばわかるものになる 。ただし 、使用している言語がユ ーザ ー定義型に対応していることが前提となる 。
- t y p e d e f やそれに相当する機能を使って単純な型を作成する場合は 、代わりに新しいクラスを作成すべきかどうかについて検討しよう 。

## 13. 特殊なデータ型

### 13.5 まとめ / check 13-1

- 構造体は 、プログラムの複雑さを和らげ 、プログラムを理解しやすく保守しやすいものにする 。
- 構造体を使用するかどうかについて検討する場合は 、それによってクラスの動作が良くなるかどうかを考える 。
- ポインタはエラ ーの原因になりやすい 。アクセスル ーチンやクラス 、防御的プログラミングを使って自衛する 。
- グロ ーバル変数を使用しない 。単にリスクがあるからという理由だけでなく 、他にもっと良い方法があるからだ 。
- グロ ーバル変数を使用せざるを得ない場合は 、アクセスル ーチンを使って操作する 。アクセスル ーチンを使用すれば 、グロ ーバル変数のすべての利点以上のものが得られる 。

# 4. ステートメント

## 14. ストレートなコードの構成

### 14.3 まとめ / check 14-1

- コ ードをストレ ートなものにする原則として最も重視されるのは 、実行順序への依存性である 。
- 依存性は 、良いル ーチン名 、引数リスト 、コメントなどを使って明白にすべきである 。コ ードがきわめて重要なものである場合は 、状態変数を使用する 。
- コ ードが実行順序に依存しない場合は 、関連するステ ートメントをできるだけ近くにまとめる 。

## 15. 条件分の使用

### 15.3 まとめ / check 15-1

- 単純な if else 文では 、それらがエラ ーをいくつも処理する場合は特に 、 if 句と else 句の順番に注意する 。正常なケ ースが明白であることを確認する 。
- if then else の連鎖と case 文は 、最も読みやすい順番に並べる 。
- case 文の default 句か 、 if then else 文の最後の else 句を使って 、エラ ーを捕捉する 。
- 制御構造の作りはどれも同じではない 。各コードブロックに最適な制御構造を選択する。

## 16. ループの制御

### 16.5 まとめ / check 16-1

- ル ープは複雑である 。ル ープを単純に保つことは 、コ ードの読み手の助けになる 。
- ル ープを単純に保つコツは 、変わったル ープを作成しない 、ネストをできるだけ少なくする 、入口と出口を明確にする 、前処理や後処理のコ ードを 1 か所にまとめる 、といったことが挙げられる 。
- ル ープ変数ほど誤用されるものはない 。ル ープ変数にはわかりやすい名前を付け 、 1 つの目的にのみ使用する 。
- ル ープ全体を入念に検討し 、すべてのケ ースで正常に実行されることと 、どのような条件でも終了することを検証する 。

## 17. 特殊な制御構造

### 17.6 まとめ / check 17-1

- 複数の r e t u r n 文は 、ル ーチンの可読性と保守性を向上させ 、深くネストしたロジックを避けるのに役立つ 。それでも 、慎重に使用すべきである 。
- 再帰は 、問題の範囲が狭い場合の的確な解決策となる 。これも慎重に使用すること 。
- 可読性と保守性の良いコ ードを書くために 、 g o t o 文が最善の方法となるケ ースがいくつかある 。しかし 、そのようなケ ースはまれである 。 g o t o 文はあくまでも最後の手段として使用する 。

## 18. テーブル駆動方式

### 18.6 まとめ / check 18-1

- テ ーブルは 、複雑なロジックや継承構造に代わる手段を提供する 。プログラムのロジックや継承ツリ ーで頭が混乱するような場合は 、参照テ ーブルを使って単純にできるかどうか検討する 。
- テ ーブルを使用するうえで重要となるのは 、テ ーブルにアクセスする方法を決定することである 。テ ーブルにアクセスする方法には 、直接アクセス 、インデックスアクセス 、段階型アクセスがある 。
- テ ーブルを使用するうえでもう 1 つ重要なのは 、テ ーブルに保存するものを正確に決定することである 。

## 19. 制御構造の問題

### 19.7 まとめ / check 19-1

- 論理式を単純で読みやすいものにすることは、コードの品質に大きく貢献する。
- 深いネストはルーチンの理解を妨げる。さいわい、この問題は比較的簡単に防ぐことができる。
- 構造化プログラミングは、今でもその価値を失っていないシンプルな概念である。どのようなプログラムも、連続、選択、反復の組み合わせで作成することができる 。
- 複雑さを最小限に抑えることは 、高品質なコ ードを書くための鍵である 。
